<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        // PASTE YOUR ENTIRE 4000-LINE CODE HERE
        // But change the import line from:
        // import React, { useState, ... } from 'react';
        // to:
        const { useState, useEffect, useMemo, useCallback, useRef } = React;
//import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';

// Lucide-react icons (assuming they are available)
// If not, these can be replaced with inline SVGs or Font Awesome
const Plus = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-plus">
    <path d="M12 5v14" /><path d="M5 12h14" />
  </svg>
);
const Minus = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-minus">
    <path d="M5 12h14" />
  </svg>
);
const Trash2 = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-trash-2">
    <path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" />
  </svg>
);
const Sword = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-sword">
    <path d="M14.5 17.5 12 15 10 17l-1 1 3 3 3-3 1-1Z" />
    <path d="M12 15V2.5l4 4L12 15Z" />
    <path d="M12 15H6.5l-.5-.5.5-.5H12Z" />
    <path d="M12 15V2.5l-4 4L12 15Z" />
    <path d="M12 15H17.5l.5-.5-.5-.5H12Z" />
  </svg>
);
const User = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-user">
    <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
    <circle cx="12" cy="7" r="4" />
  </svg>
);
const Heart = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-heart">
    <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" />
  </svg>
);
const Skull = ({ color = 'currentColor', className = '' }) => ( // Added color and className props
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`lucide lucide-skull ${className}`}>
    <circle cx="12" cy="12" r="10" />
    <path d="M12 8a3 3 0 0 0-3 3v1a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v3a3 3 0 0 0 3 3h4a2 2 0 0 0 2-2V7a2 2 0  0 0-2-2h-2a2 2 0 0 0-2 2v3a3 3 0 0 0 3 3h0" />
    <path d="M9 17v1a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-1" />
  </svg>
);
const ShieldCheck = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-shield-check">
    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10Z" />
    <path d="m9 12 2 2 4-4" />
  </svg>
);
const Dice = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-dice">
    <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
    <path d="M16 8h.01" />
    <path d="M8 16h.01" />
    <path d="M10 10h.01" />
    <path d="M14 14h.01" />
  </svg>
);
const Footprints = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-footprints">
    <path d="M4 16v-2.38C4 11.5 2.97 10.5 3 8c0-1.5 1.5-2 2-2.5S6.5 3 7 3c2 0 5 5.5 5 8v5" />
    <path d="M18 16v-2.38C18 11.5 19.03 10.5 19 8c0-1.5-1.5-2-2-2.5S15.5 3 15 3c-2 0-5 5.5-5 8v5" />
    <path d="M17.5 19h-1.4c-1.3 0-2.6-.4-3.6-1.2l-1.3-1c-.6-.4-1.3-.6-2-.6H6" />
    <path d="M18 18.5a4 4 0 0 1-1.4 3c-.9.6-2 .9-3.1.9h-1.4c-1.3 0-2.6-.4-3.6-1.2L6.5 19" />
  </svg>
);
const Bolt = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-bolt">
    <path d="M21 16V8a2 2 0 0 0-2-2h-3.48a2 2 0 0 1-1.93-1.48A2 2 0 0 0 12 2a2 2 0 0 0-1.59.52A2 2 0 0 1 8.48 6H5a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h3.48a2 2 0 0 1 1.93 1.48A2 2 0 0 0 12 22a2 2 0 0 0 1.59-.52A2 2 0 0 1 15.52 18H19a2 2 0 0 0 2-2Z" />
    <path d="M14 13h-4v3H8V9h4V6h2v7Z" />
  </svg>
);
const Check = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-check">
    <path d="M20 6 9 17l-5-5" />
  </svg>
);
const ScrollText = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucude-scroll-text">
    <path d="M2 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Z" />
    <path d="M8 7h6" />
    <path d="M8 11h6" />
    <path d="M8 15h6" />
  </svg>
);
const RotateCcw = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-rotate-ccw">
    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.79 2.91L3 12H2.5" />
    <path d="M3 6v6h6" />
  </svg>
);
const Lock = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-lock">
    <rect width="18" height="11" x="3" y="11" rx="2" ry="2" />
    <path d="M7 11V7a5 5 0 0 1 10 0v4" />
  </svg>
);
const LockOpen = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-lock-open">
    <rect width="18" height="11" x="3" y="11" rx="2" ry="2" />
    <path d="M7 11V7a5 5 0 0 1 10 0v4" />
    <path d="M12 17v-6" />
  </svg>
);
const ChevronDown = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-chevron-down">
    <path d="m6 9 6 6 6-6" />
  </svg>
);
const ChevronUp = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-chevron-up">
    <path d="m18 15-6-6-6 6" />
  </svg>
);
const Gem = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-gem">
    <path d="M6 3h12l4 6-10 13L2 9Z" />
    <path d="M11 3 8 9l4 13 4-13-3-6" />
    <path d="M2 9h20" />
  </svg>
);
const Shirt = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-shirt">
    <path d="M20.38 3.46 16 2a4 4 0 0 1-4 4 4 4 0 0 1-4-4L3.62 3.46a2 2 0 0 0-1.34 2.23l.58 3.47a1 1 0 0 0 .99.84h16.29a1 1 0 0 0 .99-.84l.58-3.47a2 2 0 0 0-1.34-2.23Z" />
    <path d="M4 9v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9" />
    <path d="M10 22v-7h4v7" />
  </svg>
);
const Scroll = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-scroll">
    <path d="M2 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Z" />
    <path d="M8 7h6" />
    <path d="M8 11h6" />
    <path d="M8 15h6" />
  </svg>
);


// Utility function to roll dice based on notation (e.g., "2d6+3")
// Returns an object with total, individual rolls, modifier, and dice part for display
const rollDiceDetailed = (diceNotation) => {
  if (!diceNotation) return { total: 0, sumOfDice: 0, rolls: [], modifier: 0, dicePart: '' };

  const parts = diceNotation.match(/(\d+)d(\d+)(?:([+-]\d+))?/); // Regex to capture optional +/- modifier
  if (!parts) {
    console.error("Invalid dice notation:", diceNotation);
    return { total: 0, sumOfDice: 0, rolls: [], modifier: 0, dicePart: diceNotation };
  }

  const numDice = parseInt(parts[1]);
  const dieType = parseInt(parts[2]);
  const modifier = parts[3] ? parseInt(parts[3]) : 0;

  let individualRolls = [];
  let sumOfDice = 0;
  for (let i = 0; i < numDice; i++) {
    const roll = Math.floor(Math.random() * dieType) + 1;
    individualRolls.push(roll);
    sumOfDice += roll;
  }
  return {
    total: sumOfDice + modifier,
    sumOfDice: sumOfDice, // Sum of just the dice rolls, without modifier
    rolls: individualRolls,
    modifier: modifier,
    dicePart: `${numDice}d${dieType}`
  };
};

// Utility function to get the maximum value of a single die type from a dice notation
const getDieTypeMax = (diceNotation) => {
  const parts = diceNotation.match(/d(\d+)/);
  if (parts && parts[1]) {
    return parseInt(parts[1]);
  }
  return 0; // Default if not found
};

// Utility function to parse dice notation into its parts (XdY and Modifier)
const parseDiceNotation = (diceNotation) => {
  const match = diceNotation.match(/^(\d+d\d+)([+-]\d+)?$/); // Updated regex to capture optional +/- modifier
  if (match) {
    return {
      dicePart: match[1], // e.g., "2d6"
      modifierPart: match[2] || '', // e.g., "+3" or "-1"
    };
  }
  return { dicePart: diceNotation, modifierPart: '' }; // Fallback for malformed notation
};

// Utility function to parse dice notation into its parts (XdY and Modifier)
const parseDiceNotationForParts = (diceNotation) => {
  if (!diceNotation) return { dicePart: '', modifier: 0 };
  const match = diceNotation.match(/^(\d+d\d+)([+-]\d+)?$/);
  if (match) {
    return {
      dicePart: match[1], // e.g., "2d6"
      modifier: match[2] ? parseInt(match[2]) : 0, // e.g., "+3" -> 3, "-1" -> -1, undefined -> 0
    };
  }
  return { dicePart: diceNotation, modifier: 0 }; // Fallback for malformed notation or just "d20"
};

// Helper to convert CR string to a comparable number
const crToNumber = (crString) => {
  if (typeof crString === 'number') return crString;
  switch (crString) {
    case '0': return 0;
    case '1/8': return 0.125;
    case '1/4': return 0.25;
    case '1/2': return 0.5;
    default: return parseFloat(crString); // For integer CRs
  }
};


// ColorPickerWheel Component
const ColorPickerWheel = ({ currentColor, allColors, onSelect, onClose }) => {
  const pickerRef = useRef(null);

  // Close picker if click outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (pickerRef.current && !pickerRef.current.contains(event.target)) {
        onClose();
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [onClose]);

  return (
    <div ref={pickerRef} className="absolute z-10 bg-gray-800 rounded-lg shadow-xl border border-gray-600 p-2 flex flex-col space-y-1"
         style={{ top: '50%', right: '100%', transform: 'translateY(-50%) translateX(-10px)' }}> {/* Position to the left of the parent */}
      {allColors.map((color, index) => (
        <div
          key={index}
          className={`w-8 h-8 rounded-full border-2 cursor-pointer transition-all duration-150
            ${currentColor === color ? 'border-white scale-110' : 'border-gray-500 hover:scale-105'}`}
          style={{ backgroundColor: color }}
          onClick={(e) => {
            e.stopPropagation(); // Prevent MiniCharacterCard's click handler
            onSelect(color);
            // onClose(); // No need to close here, onSelect will handle it or parent will
          }}
        ></div>
      ))}
    </div>
  );
};

// New NumberScroller Component
const NumberScroller = ({ value, onChange, min, max, step = 1, displayUnit = '', isDefaultValueDisplay = false, hideControls = false, inputWidthClass = 'w-14', buttonPaddingClass = 'p-0.5', iconSizeClass = 'w-3 h-3', readOnly = false, displayValue = '', textColorClass = '' }) => {
  // Ensure value is treated as a number for internal logic, but can be an empty string for initial state/placeholder
  const parsedValue = value === '' ? min : parseInt(value);

  const handleDecrement = () => {
    if (readOnly) return; // Prevent decrement if readOnly
    const newValue = Math.max(min, parsedValue - step);
    onChange(newValue.toString());
  };

  const handleIncrement = () => {
    if (readOnly) return; // Prevent increment if readOnly
    const newValue = Math.min(max, parsedValue + step);
    onChange(newValue.toString());
  };

  // Conditional text color based on isDefaultValueDisplay prop
  const finalTextColorClass = textColorClass || (isDefaultValueDisplay ? 'text-gray-400' :
                         (parsedValue < 0 ? 'text-red-400' : parsedValue > 0 ? 'text-blue-400' : 'text-white'));

  return (
    <div className="flex items-center space-x-1">
      {!hideControls && (
        <button
          onClick={handleDecrement}
          className={`${buttonPaddingClass} bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors duration-200`}
          aria-label="Decrease value"
          disabled={parsedValue <= min || readOnly}
        >
          <Minus className={iconSizeClass} />
        </button>
      )}
      <input
        type="number"
        value={readOnly ? displayValue : value} // Use displayValue if readOnly, otherwise use actual value
        onChange={(e) => {
          if (readOnly) return; // Prevent change if readOnly
          const val = e.target.value;
          if (val === '') {
            onChange(''); // Allow empty string for user to type
          } else {
            const num = parseInt(val);
            if (!isNaN(num)) {
              onChange(Math.min(max, Math.max(min, num)).toString());
            }
          }
        }}
        min={min}
        max={max}
        readOnly={readOnly} // Set readOnly attribute
        className={`${inputWidthClass} ${buttonPaddingClass} rounded-lg text-center bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 ${finalTextColorClass} ${readOnly ? 'cursor-default' : ''}`}
      />
      {!hideControls && (
        <button
          onClick={handleIncrement}
          className={`${buttonPaddingClass} bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors duration-200`}
          aria-label="Increase value"
          disabled={parsedValue >= max || readOnly}
        >
          <Plus className={iconSizeClass} />
        </button>
      )}
    </div>
  );
};

// Define D&D 5e Status Effects and their properties
const STATUS_EFFECTS = {
  'active': { description: 'No special conditions.', colorClass: 'bg-green-500' },
  'blinded': { description: 'Disadvantage on attack rolls and Perception checks that rely on sight. Attack rolls against them have advantage.', colorClass: 'bg-yellow-500' },
  'charmed': { description: 'Cannot attack the charmer or target them with harmful abilities or magical effects. The charmer has advantage on any ability check to interact socially with them.', colorClass: 'bg-pink-500' },
  'deafened': { description: 'Automatically fails any ability check that relies on hearing.', colorClass: 'bg-yellow-500' },
  'frightened': { description: 'Disadvantage on ability checks and attack rolls while the source of its fear is within line of sight. Cannot willingly move closer to the source of its fear.', colorClass: 'bg-orange-500' },
  'grappled': { description: 'Speed becomes 0, and can\'t benefit from any bonus to speed. The condition ends if the grappler is incapacitated or if the grappled creature escapes.', movement: 0, colorClass: 'bg-purple-500' },
  'incapacitated': { description: 'Cannot take actions or reactions.', colorClass: 'bg-gray-500' },
  'invisible': { description: 'Cannot be seen without the aid of magic or a special sense. For the purpose of hiding, the creature is heavily obscured. Attack rolls against the creature have disadvantage, and the creature’s attack rolls have advantage.', colorClass: 'bg-indigo-500' },
  'paralyzed': { description: 'Incapacitated and cannot move or speak. Automatically fails Strength and Dexterity saving throws. Attack rolls against the creature have advantage. Any attack that hits the creature is a critical hit if the attacker is within 5 feet of the creature.', movement: 0, colorClass: 'bg-blue-500' },
  'petrified': { description: 'Transformed into a solid inanimate substance. Incapacitated, cannot move or speak, and is unaware of its surroundings. Attack rolls against the creature have advantage. The creature has resistance to all damage. Automatically fails Strength and Dexterity saving throws.', movement: 0, colorClass: 'bg-gray-600' },
  'poisoned': { description: 'Disadvantage on attack rolls and ability checks.', colorClass: 'bg-lime-500' },
  'prone': { description: 'Can only crawl (movement half) or use half its movement to stand up. Disadvantage on attack rolls. Attack rolls against them have advantage if attacker is within 5ft, disadvantage otherwise.', movementMultiplier: 0.5, colorClass: 'bg-amber-500' },
  'restrained': { description: 'Speed becomes 0, and can\'t benefit from any bonus to speed. Attack rolls have disadvantage. Attack rolls against them have advantage. Disadvantage on Dexterity saving throws.', movement: 0, colorClass: 'bg-purple-500' },
  'stunned': { description: 'Incapacitated, cannot move or speak, and is unaware of its surroundings. Automatically fails Strength and Dexterity saving throws. Attack rolls against the creature have advantage.', movement: 0, colorClass: 'bg-blue-500' },
  'unconscious': { description: 'Incapacitated, cannot move or speak, and is unaware of its surroundings. Drops held items and falls prone. Attack rolls against the creature have advantage. Any attack that hits the creature from within 5 feet is a critical hit. Automatically fails Strength and Dexterity saving throws.', movement: 0, colorClass: 'bg-red-700' },
  'dead': { description: 'The creature is dead. Cannot take actions, reactions, or move. Automatically fails all saving throws.', movement: 0, colorClass: 'bg-gray-900' }
};

// CombatantDetails component for the left-hand panel
const CombatantDetails = ({ character, onUpdateHp, onToggleRemovedFromCombat, onUpdateStatus, onUpdateActionCheckbox, onUpdateCurrentMovement, onUpdateActions, addLogEntry, onUpdateCharacterName,
  newCustomWeaponName, setNewCustomWeaponName, newCustomWeaponNumDice, setNewCustomWeaponNumDice, newCustomWeaponDieType, setNewCustomWeaponDieType, newCustomWeaponModifier, setNewCustomWeaponModifier,
  selectedDamageTypeForNewWeapon, setSelectedDamageTypeForNewWeapon, customDamageTypeName, setCustomDamageTypeName, newCustomWeaponToHitModifier, setNewCustomWeaponToHitModifier,
  onTogglePanelLock, // Receive lock state and setter
  onUpdateAbilityRoll, // Receive the new prop for updating ability rolls
  onActivateTrait // New prop for activating traits
}) => {
  const [hpAdjustmentAmount, setHpAdjustmentAmount] = useState('');
  const [movementAdjustmentAmount, setMovementAdjustmentAmount] = useState('');
  const [lastRollMessage, setLastRollMessage] = useState(null); // General roll message
  const [weaponDamageRolls, setWeaponDamageRolls] = useState({}); // Specific damage roll results for each weapon
  const [weaponToHitRolls, setWeaponToHitRolls] = useState({}); // Specific to-hit roll results for each weapon
  const [showStats, setShowStats] = useState(false); // State for showing/hiding ability scores
  const [criticalHitFlags, setCriticalHitFlags] = useState({}); // New state to track critical hits for each weapon

  // New state for collapsible custom weapon form (default to false)
  const [showAddCustomWeaponForm, setShowAddCustomWeaponForm] = useState(false);
  // New state for collapsible traits section (default to false)
  const [showTraits, setShowTraits] = useState(false);

  const MAX_CUSTOM_WEAPONS = 8;

  if (!character) {
    return (
      <div className="p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600 text-center text-gray-400">
        Select a combatant from the list to view details.
      </div>
    );
  }

  const hpPercentage = (character.hp / character.maxHp) * 100;
  const hpColorClass = hpPercentage > 50 ? 'bg-green-500' : hpPercentage > 20 ? 'bg-yellow-500' : 'bg-red-500';

  const calculateModifier = (score) => Math.floor((score - 10) / 2);

  const handleStatRoll = (statName, modifier) => {
    const d20Roll = Math.floor(Math.random() * 20) + 1;
    const total = d20Roll + modifier;
    // Update the character's lastAbilityRoll directly via prop
    onUpdateAbilityRoll(character.id, { stat: statName, roll: d20Roll, total: total });
    addLogEntry({ type: 'skill', characterId: character.id, message: `rolled ${statName} check:`, value: total, details: `(${d20Roll} + ${modifier})` });
  };

  const handleHpAdjustment = (type) => {
    const amount = parseInt(hpAdjustmentAmount);
    if (isNaN(amount) || amount < 1 || amount > 200) { // Enforce min 1, max 200
      console.warn("Please enter a valid number between 1 and 200 for HP adjustment.");
      return;
    }
    let newHp = character.hp;
    if (type === 'add') {
      newHp = character.hp + amount;
      addLogEntry({ type: 'hp_change', characterId: character.id, message: `healed`, value: amount, hpChangeType: 'heal' });
    } else if (type === 'subtract') {
      newHp = character.hp - amount;
      addLogEntry({ type: 'hp_change', characterId: character.id, message: `took damage`, value: amount, hpChangeType: 'damage' });
    }
    onUpdateHp(character.id, newHp);
    setHpAdjustmentAmount(''); // Clear input after adjustment
  };

  const handleMovementAdjustment = (type) => {
    const amount = parseInt(movementAdjustmentAmount);
    if (isNaN(amount) || amount < 1 || amount > 200) { // Enforce min 1, max 200
      console.warn("Please enter a valid number between 1 and 200 for movement adjustment.");
      return;
    }
    let newMovement = character.currentMovement;
    if (type === 'add') {
      newMovement = character.currentMovement + amount;
    } else if (type === 'subtract') {
      newMovement = character.currentMovement - amount;
    }
    onUpdateCurrentMovement(character.id, newMovement);
    setMovementAdjustmentAmount(''); // Clear input after adjustment
  };

  const handleResetActions = () => {
    onUpdateActionCheckbox(character.id, 'actionUsed', false);
    onUpdateActionCheckbox(character.id, 'bonusActionUsed', false);
    onUpdateActionCheckbox(character.id, 'dashUsed', false);
    onUpdateActionCheckbox(character.id, 'reactionUsed', false);
    onUpdateActionCheckbox(character.id, 'turnCompleted', false); // Also reset turn completed
  };

  // Function to handle rolling a weapon's damage dice
  const handleRollDamage = (actionId, weaponName, diceNotation, damageType) => {
    let rollResult;
    let logMessagePrefix;
    let displayMessage;

    if (criticalHitFlags[actionId]) {
      // Critical hit damage calculation: (max damage value from original base die) + (random rolled value using normal attack die) + (modifiers)
      const maxDieValue = getDieTypeMax(diceNotation);
      const normalRoll = rollDiceDetailed(diceNotation); // This gives XdY + Z
      const criticalTotal = maxDieValue + normalRoll.sumOfDice + normalRoll.modifier;

      rollResult = { total: criticalTotal, rolls: [...normalRoll.rolls, maxDieValue], modifier: normalRoll.modifier, dicePart: normalRoll.dicePart };

      const mathString = `${maxDieValue} (max) + ${normalRoll.rolls.join(' + ')}` + (normalRoll.modifier !== 0 ? ` ${normalRoll.modifier > 0 ? '+' : ''}${normalRoll.modifier}` : '');
      logMessagePrefix = `rolled CRITICAL ${weaponName} damage:`;
      addLogEntry({ type: 'damage', characterId: character.id, message: logMessagePrefix, value: criticalTotal, details: `(${mathString}) ${damageType ? `[${damageType}]` : ''}`, isCrit: true });
      displayMessage = `${weaponName} CRIT Damage: ${criticalTotal} (${rollResult.dicePart} + ${maxDieValue}${rollResult.modifier !== 0 ? (rollResult.modifier > 0 ? `+${rollResult.modifier}` : `${rollResult.modifier}`) : ''})`;

    } else {
      // Normal damage calculation
      rollResult = rollDiceDetailed(diceNotation);
      const mathString = rollResult.rolls.join(' + ') + (rollResult.modifier !== 0 ? ` ${rollResult.modifier > 0 ? '+' : ''}${rollResult.modifier}` : '');
      logMessagePrefix = `rolled ${weaponName} damage:`;
      addLogEntry({ type: 'damage', characterId: character.id, message: logMessagePrefix, value: rollResult.total, details: `(${mathString}) ${damageType ? `[${damageType}]` : ''}` });
      displayMessage = `${weaponName} Damage: ${rollResult.total} (${rollResult.dicePart}${rollResult.modifier !== 0 ? (rollResult.modifier > 0 ? `+${rollResult.modifier}` : `${rollResult.modifier}`) : ''})`;
    }

    setWeaponDamageRolls(prevRolls => ({
      ...prevRolls,
      [actionId]: rollResult.total
    }));

    setLastRollMessage(displayMessage);

    // Reset critical hit flag after rolling damage
    setCriticalHitFlags(prevFlags => ({
      ...prevFlags,
      [actionId]: false
    }));

    setTimeout(() => {
      setLastRollMessage(null);
    }, 5000); // Clear general message after 5 seconds
  };

  // Function to handle rolling a weapon's to-hit dice
  const handleRollToHit = (actionId, weaponName, toHitModifier) => {
    const d20Roll = Math.floor(Math.random() * 20) + 1;
    const totalToHit = d20Roll + toHitModifier;

    setWeaponToHitRolls(prevRolls => ({
      ...prevRolls,
      [actionId]: totalToHit
    }));

    // Set critical hit flag if natural 20 is rolled
    setCriticalHitFlags(prevFlags => ({
      ...prevFlags,
      [actionId]: d20Roll === 20
    }));

    const modifierString = toHitModifier !== 0 ? (toHitModifier > 0 ? `+${toHitModifier}` : `${toHitModifier}`) : '';
    addLogEntry({ type: 'to_hit', characterId: character.id, message: `rolled ${weaponName} to hit:`, value: totalToHit, details: `(${d20Roll}${modifierString})`, isCrit: d20Roll === 20 });

    setLastRollMessage(`${weaponName} To Hit: ${totalToHit} (${d20Roll}${modifierString}${d20Roll === 20 ? ' (CRITICAL!)' : ''})`);
    setTimeout(() => {
      setLastRollMessage(null);
    }, 5000); // Clear general message after 5 seconds

    // AUTOMATICALLY CHECK 'Action' if not already used and not Dash
    if (!character.actionUsed && !character.dashUsed && !(character.isDying || character.status === 'dead')) {
      onUpdateActionCheckbox(character.id, 'actionUsed', true);
    }
  };


  // Function to add a new custom weapon
  const handleAddCustomWeapon = () => {
    if (!newCustomWeaponName.trim()) {
      console.warn("Weapon name cannot be empty.");
      return;
    }
    if (character.actions.length >= MAX_CUSTOM_WEAPONS) {
      console.warn(`Cannot add more than ${MAX_CUSTOM_WEAPONS} custom weapons.`);
      return;
    }

    const modifierValue = parseInt(newCustomWeaponModifier);
    const modifierPart = !isNaN(modifierValue) && modifierValue !== 0 ?
                         (modifierValue > 0 ? `+${modifierValue}` : `${modifierValue}`) : '';
    const diceNotation = `${newCustomWeaponNumDice}${newCustomWeaponDieType}${modifierPart}`;

    // Ensure toHitModifier is 0 if input is empty, so the button always appears
    const toHitModifierValue = parseInt(newCustomWeaponToHitModifier);
    const finalToHitModifier = !isNaN(toHitModifierValue) ? toHitModifierValue : 0;

    // Determine the damage type based on dropdown selection
    const finalDamageType = selectedDamageTypeForNewWeapon === 'Other'
      ? customDamageTypeName.trim() || undefined
      : selectedDamageTypeForNewWeapon;

    const newWeapon = {
      id: crypto.randomUUID(), // Assign unique ID for tracking rolls
      name: newCustomWeaponName.trim(),
      dice: diceNotation,
      damageType: finalDamageType, // Use the determined damage type
      toHitModifier: finalToHitModifier, // Use the determined toHitModifier
      isCustom: true, // Mark as custom
    };

    onUpdateActions(character.id, [...character.actions, newWeapon]);
    // No longer clearing inputs here, as they are managed by App component
  };


  // Effect to automatically check 'turnCompleted'
  useEffect(() => {
    if (character) {
      const isPrimaryActionUsed = character.actionUsed || character.dashUsed;
      const isBonusActionUsed = character.bonusActionUsed;
      const isReactionUsed = character.reactionUsed;
      const isMovementExhausted = character.currentMovement !== undefined && character.currentMovement <= 0;

      // Condition for auto-checking 'turnCompleted'
      // "if all actions are checked (or) the dash is checked, and all bonus actions are checked, and all movementmis exhausted"
      // Interpreting "all actions" as (actionUsed AND reactionUsed) OR dashUsed
      const autoCheckCondition = (
        ((character.actionUsed && character.reactionUsed) || character.dashUsed) &&
        isBonusActionUsed &&
        isMovementExhausted
      );

      // Only auto-check if the character is NOT dying or dead
      if (autoCheckCondition && !character.turnCompleted && !(character.isDying || character.status === 'dead')) {
        onUpdateActionCheckbox(character.id, 'turnCompleted', true);
      }
      // If character becomes dying or dead, force turnCompleted to true
      if ((character.isDying || character.status === 'dead') && !character.turnCompleted) {
        onUpdateActionCheckbox(character.id, 'turnCompleted', true);
      }
    }
  }, [
    character,
    character.actionUsed,
    character.bonusActionUsed,
    character.dashUsed,
    character.reactionUsed,
    character.currentMovement,
    character.turnCompleted,
    character.isDying, // Added dependency
    character.status, // Added dependency
    onUpdateActionCheckbox
  ]);


  return (
    <div className={`p-6 rounded-xl shadow-lg transition-all duration-300 border mt-4
      ${character.status === 'dead' ? 'bg-gray-700 text-gray-400' :
        character.status === 'unconscious' ? 'bg-red-900 text-red-300' :
        'bg-gray-700 text-white'}`}>
      <h2 className="text-2xl font-bold mb-4 text-center">
        {character.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond icon for custom */}
        <input
          type="text"
          value={character.name}
          onChange={(e) => onUpdateCharacterName(character.id, e.target.value)}
          maxLength={30} // Max length for character name
          className="bg-transparent border-b-2 border-gray-500 hover:border-purple-500 focus:border-purple-500 focus:outline-none text-white text-center text-2xl font-bold w-full"
          aria-label="Combatant Name"
        />
        {character.species && <span className="text-xl font-normal text-gray-400"> ({character.species})</span>}
      </h2>

      {/* Keep Open Toggle Button */}
      <div className="flex justify-center mb-4">
        <button
          onClick={() => onTogglePanelLock(character.id, !character.isLocked)}
          className={`py-2 px-4 rounded-lg font-semibold transition-colors duration-200 flex items-center space-x-2
            ${character.isLocked ? 'bg-purple-700 text-white hover:bg-purple-800' : 'bg-gray-600 text-gray-300 hover:bg-gray-500'}`}
          title={character.isLocked ? "Unlock details panel (will close on selecting other combatants)" : "Lock details panel (will stay open when selecting other combatants)"}
        >
          {character.isLocked ? <Lock className="w-5 h-5" /> : <LockOpen className="w-5 h-5" />}
          <span>{character.isLocked ? 'Panel Locked' : 'Panel Unlocked'}</span>
        </button>
      </div>

      {lastRollMessage && (
        <div className="bg-blue-600 text-white p-3 rounded-lg mb-4 text-center font-semibold animate-bounce">
          {lastRollMessage}
        </div>
      )}

      <div className="grid grid-cols-2 gap-4 mb-4">
        <div className="flex items-center space-x-2">
          <ShieldCheck className="w-6 h-6 text-gray-400" />
          <span className="font-semibold">AC: {character.ac || 'N/A'}</span>
        </div>
        <div className="flex items-center space-x-2">
          <Footprints className="w-6 h-6 text-gray-400" />
          <span className="font-semibold">Movement: {character.movement || 'N/A'}</span>
        </div>
      </div>

      {/* HP Display and Adjustment */}
      <div className="mb-4">
        <div className="flex items-center space-x-2 mb-2">
          <Heart className={`w-6 h-6 ${character.status === 'dead' ? 'text-gray-500' : 'text-red-500'}`} />
          <span className="font-bold text-xl">HP: {character.hp} / {character.maxHp}</span>
        </div>
        <div className="w-full bg-gray-300 rounded-full h-3 mb-2">
          <div className={`${hpColorClass} h-3 rounded-full`} style={{ width: `${hpPercentage}%` }}></div>
        </div>
        <div className="flex items-center space-x-2">
          <button
            onClick={() => handleHpAdjustment('subtract')}
            className="p-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors duration-200"
            aria-label="Decrease HP by amount"
            disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
          >
            <Minus className="w-5 h-5" />
          </button>
          <input
            type="number"
            value={hpAdjustmentAmount}
            onChange={(e) => setHpAdjustmentAmount(e.target.value)}
            placeholder="Amount"
            min="1" // Minimum value for adjustment
            max="200" // Maximum value for adjustment
            className="w-24 p-2 rounded-lg text-center bg-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
          />
          <button
            onClick={() => handleHpAdjustment('add')}
            className="p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors duration-200"
            aria-label="Increase HP by amount"
            disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
          >
            <Plus className="w-5 h-5" />
          </button>
        </div>
      </div>

      {/* Current Movement Display and Adjustment */}
      {character.movement && (
        <div className="mb-4">
          <div className="flex items-center space-x-2 mb-2">
            <Footprints className="w-6 h-6 text-gray-400" />
            <span className={`font-bold text-xl ${character.isMovementDashed ? 'text-blue-400' : ''}`}>Current Movement: {character.currentMovement || 0}ft</span>
          </div>
          <div className="flex items-center space-x-2">
            <button
              onClick={() => handleMovementAdjustment('subtract')}
              className="p-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors duration-200"
              aria-label="Decrease Movement by amount"
              disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
            >
              <Minus className="w-5 h-5" />
            </button>
          <input
            type="number"
            value={movementAdjustmentAmount}
            onChange={(e) => setMovementAdjustmentAmount(e.target.value)}
            placeholder="Amount"
            min="1" // Minimum value for adjustment
            max="200" // Maximum value for adjustment
            className="w-24 p-2 rounded-lg text-center bg-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
          />
          <button
            onClick={() => handleMovementAdjustment('add')}
            className="p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors duration-200"
            aria-label="Increase Movement by amount"
            disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
          >
            <Plus className="w-5 h-5" />
          </button>
        </div>
      </div>
      )}


      {/* Status and Actions */}
      <div className="mb-4">
        <label htmlFor="status-select" className="block text-sm font-medium text-gray-400 mb-1">Status</label>
        <select
          id="status-select"
          value={character.status}
          onChange={(e) => onUpdateStatus(character.id, e.target.value)}
          className={`p-2 rounded-md text-sm font-medium focus:ring-2 focus:ring-offset-2 w-full
            ${STATUS_EFFECTS[character.status]?.colorClass || 'bg-gray-500'} text-white`}
          disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
        >
          {Object.keys(STATUS_EFFECTS).map(statusKey => (
            <option key={statusKey} value={statusKey} className={`${STATUS_EFFECTS[statusKey]?.colorClass || 'bg-gray-500'} text-white`}>
              {statusKey.charAt(0).toUpperCase() + statusKey.slice(1)}
            </option>
          ))}
        </select>
        {character.status !== 'active' && (
          <p className="text-xs text-gray-400 mt-2 italic">
            **Effect:** {STATUS_EFFECTS[character.status]?.description}
          </p>
        )}
      </div>

      {/* New: Ability Scores Section */}
      <div className="mb-4">
        <button
          onClick={() => setShowStats(!showStats)}
          className="w-full py-2 px-4 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors duration-200"
        >
          {showStats ? 'Hide Stats' : 'Show Stats'}
        </button>

        {showStats && (
          <div className="mt-3 p-4 bg-gray-600 rounded-lg border border-gray-500">
            <div className="flex justify-between items-center mb-2"> {/* Use flex to align title and roll result */}
              <h4 className="text-md font-semibold">Ability Scores</h4>
              {character.lastAbilityRoll && (
                <div className="flex items-center space-x-2 bg-gray-800 px-3 py-1 rounded-full shadow-md">
                  <span className="text-xs text-gray-400 font-semibold">Skill Check:</span>
                  <span className="text-lg text-blue-300 font-bold animate-pulse">
                    {character.lastAbilityRoll.total}
                  </span>
                  <span className="text-xs text-gray-500">({character.lastAbilityRoll.stat})</span>
                </div>
              )}
            </div>
            <div className="grid grid-cols-2 gap-2 text-sm">
              {['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'].map(stat => {
                const score = character[stat.toLowerCase()] || 10; // Default to 10 if not set
                const modifier = calculateModifier(score);
                const modifierDisplay = modifier >= 0 ? `+${modifier}` : `${modifier}`;
                return (
                  <div key={stat} className="flex flex-col items-center justify-center p-2 bg-gray-700 rounded-md">
                    <button
                      onClick={() => handleStatRoll(stat, modifier)}
                      className="flex items-center space-x-1 text-lg font-bold text-gray-200 hover:text-purple-300 transition-colors"
                      title={`Roll ${stat} Check`}
                      disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
                    >
                      <span>{stat}</span>
                      <Dice className="w-5 h-5 text-green-400" /> {/* Green Dice Icon */}
                    </button>
                    <span className="text-white text-xl font-bold">{score}</span>
                    <span className="text-sm text-gray-400">({modifierDisplay})</span>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>

      {/* New: Traits Section */}
      {character.traits && character.traits.length > 0 && (
        <div className="mb-4">
          <button
            onClick={() => setShowTraits(!showTraits)}
            className="w-full py-2 px-4 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors duration-200"
          >
            {showTraits ? 'Hide Traits' : 'Show Traits'}
          </button>

          {showTraits && (
            <div className="mt-3 p-4 bg-gray-600 rounded-lg border border-gray-500">
              <h4 className="text-md font-semibold mb-3 flex items-center space-x-2">
                <Scroll className="w-5 h-5 text-gray-400" />
                <span>Creature Traits</span>
              </h4>
              <ul className="space-y-3">
                {character.traits.map(trait => {
                  const isTraitActive = character.actions.some(a => a.id === trait.id);
                  const isActionUsed =
                    (trait.actionType === 'action' && character.actionUsed) ||
                    (trait.actionType === 'bonusAction' && character.bonusActionUsed) ||
                    (trait.actionType === 'reaction' && character.reactionUsed);
                  const isDisabledForActivation = character.isDying || character.status === 'dead' || isActionUsed;

                  return (
                    <li key={trait.id} className="flex flex-col p-2 bg-gray-700 rounded-md border border-gray-600">
                      <div className="flex items-center justify-between mb-1">
                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={isTraitActive}
                            onChange={(e) => {
                              const newActions = e.target.checked
                                ? [...character.actions, { ...trait, isCustom: true, isTrait: true }] // Add trait to actions
                                : character.actions.filter(a => a.id !== trait.id); // Remove trait from actions
                              onUpdateActions(character.id, newActions);
                            }}
                            disabled={character.isDying || character.status === 'dead'} // Disable if dead/dying
                            className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                          />
                          <span className={`ml-2 text-base font-semibold ${isTraitActive ? 'text-purple-300' : 'text-gray-200'}`}>
                            {trait.name}
                          </span>
                        </label>
                        {trait.actionType && trait.actionType !== 'passive' && trait.actionType !== 'free' && (
                          <button
                            onClick={() => onActivateTrait(character.id, trait, trait.actionType)}
                            className={`py-1 px-3 rounded-md text-xs font-medium transition-colors duration-200 flex items-center space-x-1
                              ${isDisabledForActivation ? 'bg-gray-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700 text-white'}`}
                            disabled={isDisabledForActivation}
                            title={`Activate ${trait.name} (${trait.actionType.replace('Action', ' Action')})`}
                          >
                            <Bolt className="w-4 h-4" />
                            <span>Activate</span>
                          </button>
                        )}
                      </div>
                      <p className="text-xs text-gray-400 italic ml-6">
                        {trait.description}
                        {trait.actionType && trait.actionType !== 'passive' && trait.actionType !== 'free' && (
                          <span className="ml-1 font-bold text-gray-500">({trait.actionType.replace('Action', ' Action')})</span>
                        )}
                      </p>
                    </li>
                  );
                })}
              </ul>
            </div>
          )}
        </div>
      )}

      {/* New: Actions Taken This Turn Checkboxes */}
      <div className="mb-4 p-4 bg-gray-600 rounded-lg border border-gray-500">
        <h3 className="text-lg font-semibold flex items-center space-x-2 mb-3 text-gray-200">
            <Bolt className="w-5 h-5 text-gray-400" />
            <span>Actions Taken This Turn:</span>
        </h3>
        <div className="grid grid-cols-2 gap-3 text-sm">
          <div className="flex items-center">
            <input
              id={`action-used-${character.id}`}
              type="checkbox"
              checked={character.actionUsed || false}
              onChange={(e) => onUpdateActionCheckbox(character.id, 'actionUsed', e.target.checked)}
              disabled={character.dashUsed || character.isDying || character.status === 'dead'} // Disable if Dash is checked OR dying/dead
              className={`h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded ${character.dashUsed || character.isDying || character.status === 'dead' ? 'opacity-50 cursor-not-allowed' : ''}`}
            />
            <label htmlFor={`action-used-${character.id}`} className={`ml-2 ${character.dashUsed || character.isDying || character.status === 'dead' ? 'text-gray-500' : 'text-gray-300'}`}>Action</label>
          </div>
          <div className="flex items-center">
            <input
              id={`bonus-action-used-${character.id}`}
              type="checkbox"
              checked={character.bonusActionUsed || false}
              onChange={(e) => onUpdateActionCheckbox(character.id, 'bonusActionUsed', e.target.checked)}
              disabled={character.isDying || character.status === 'dead'} // Disable if dying/dead
              className={`h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded ${character.isDying || character.status === 'dead' ? 'opacity-50 cursor-not-allowed' : ''}`}
            />
            <label htmlFor={`bonus-action-used-${character.id}`} className={`ml-2 ${character.isDying || character.status === 'dead' ? 'text-gray-500' : 'text-gray-300'}`}>Bonus Action</label>
          </div>
          <div className="flex items-center">
            <input
              id={`dash-used-${character.id}`}
              type="checkbox"
              checked={character.dashUsed || false}
              onChange={(e) => onUpdateActionCheckbox(character.id, 'dashUsed', e.target.checked)}
              disabled={character.actionUsed || character.isDying || character.status === 'dead'} // Disable if Action is checked OR dying/dead
              className={`h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded ${character.actionUsed || character.isDying || character.status === 'dead' ? 'opacity-50 cursor-not-allowed' : ''}`}
            />
            <label htmlFor={`dash-used-${character.id}`} className={`ml-2 ${character.actionUsed || character.isDying || character.status === 'dead' ? 'text-gray-500' : 'text-gray-300'}`}>Dash</label>
          </div>
          <div className="flex items-center">
            <input
              id={`reaction-used-${character.id}`}
              type="checkbox"
              checked={character.reactionUsed || false}
              onChange={(e) => onUpdateActionCheckbox(character.id, 'reactionUsed', e.target.checked)}
              disabled={character.isDying || character.status === 'dead'} // Disable if dying/dead
              className={`h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded ${character.isDying || character.status === 'dead' ? 'opacity-50 cursor-not-allowed' : ''}`}
            />
            <label htmlFor={`reaction-used-${character.id}`} className={`ml-2 ${character.isDying || character.status === 'dead' ? 'text-gray-500' : 'text-gray-300'}`}>Reaction</label>
          </div>
        </div>
        <button
          onClick={handleResetActions}
          disabled={character.isDying || character.status === 'dead'} // Disable if dying/dead
          className={`w-full py-2 px-4 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-colors duration-200 mt-4 text-sm
            ${character.isDying || character.status === 'dead' ? 'opacity-50 cursor-not-allowed' : ''}`}
        >
          Reset Actions for Turn
        </button>
      </div>


      {/* Available Actions / Weapons */}
      {character.actions && character.actions.length > 0 && (
        <div className="mb-4">
          <h3 className="text-lg font-semibold flex items-center space-x-2 mb-2 text-gray-200">
            <Sword className="w-5 h-5 text-gray-400" />
            <span>Available Attacks/Weapons:</span>
          </h3>
          <ul className="list-disc list-inside text-gray-300 space-y-2">
            {character.actions.map((action) => {
              // Determine if this is a trait or a weapon
              const isTrait = action.isTrait;
              const toHitModifierString = action.toHitModifier !== undefined && action.toHitModifier !== 0 ?
                                          (action.toHitModifier > 0 ? `+${action.toHitModifier}` : `${action.toHitModifier}`) : '';
              const isCritical = criticalHitFlags[action.id];

              return (
                <li key={action.id} className="flex flex-col sm:flex-row items-start sm:items-center justify-between border-b border-gray-600 pb-2 last:border-b-0">
                  <div className="flex items-center flex-grow mb-2 sm:mb-0">
                    {action.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond for custom actions/traits */}
                    <span className="font-semibold text-gray-200">{action.name}</span>
                    {isTrait ? (
                      <span className="ml-2 text-xs text-gray-400">({action.description})</span>
                    ) : (
                      action.damageType && (
                        <span className="ml-2 text-xs text-gray-400">({action.damageType})</span>
                      )
                    )}
                  </div>

                  {!isTrait && ( // Only show roll buttons for non-trait actions
                    <div className="flex items-center space-x-2 flex-wrap sm:flex-nowrap">
                      {/* To Hit Roll */}
                      {(action.toHitModifier !== undefined) && ( // Show if 0 or any other number
                        <div className="flex items-center mr-2">
                          <span className="w-10 text-right mr-1 font-bold text-md text-green-300">
                            {weaponToHitRolls[action.id] !== undefined ? weaponToHitRolls[action.id] : ''}
                          </span>
                          <button
                            onClick={() => handleRollToHit(action.id, action.name, action.toHitModifier)}
                            className="p-1.5 bg-green-700 text-white rounded-md hover:bg-green-800 transition-colors duration-200 flex items-center text-sm"
                            title={`Roll To Hit (1d20${toHitModifierString})`}
                            disabled={character.isDying || character.status === 'dead' || character.actionUsed || character.dashUsed} // Disable if dying/dead or action used
                          >
                            <Dice className="w-4 h-4 mr-1" /> To Hit
                          </button>
                          {toHitModifierString && (
                            <span className="ml-1 text-sm text-gray-400">
                              {toHitModifierString}
                            </span>
                          )}
                        </div>
                      )}

                      {/* Damage Roll */}
                      {action.dice && (
                        <div className="flex items-center">
                          <span className="w-10 text-right mr-1 font-bold text-md text-blue-300">
                            {weaponDamageRolls[action.id] !== undefined ? weaponDamageRolls[action.id] : ''}
                          </span>
                          <button
                            onClick={() => handleRollDamage(action.id, action.name, action.dice, action.damageType)}
                            className={`p-1.5 text-white rounded-md transition-colors duration-200 flex items-center text-sm
                              ${isCritical ? 'bg-red-600 hover:bg-red-700' : 'bg-blue-600 hover:bg-blue-700'}`}
                            title={`Roll Damage (${action.dice}) ${isCritical ? '(CRITICAL)' : ''}`}
                            disabled={character.isDying || character.status === 'dead'} // Disable if dying/dead
                          >
                            <Dice className="w-4 h-4 mr-1" /> {parseDiceNotation(action.dice).dicePart}
                          </button>
                          {parseDiceNotation(action.dice).modifierPart && (
                            <span className="ml-1 text-sm text-gray-400">
                              {parseDiceNotation(action.dice).modifierPart}
                            </span>
                          )}
                        </div>
                      )}
                    </div>
                  )}
                </li>
              );
            })}
          </ul>
        </div>
      )}

      {/* Add Custom Weapon/Attack Section - Now Collapsible */}
      <div className="mb-4 p-4 bg-gray-600 rounded-lg border border-gray-500">
        <button
          onClick={() => setShowAddCustomWeaponForm(!showAddCustomWeaponForm)}
          className="w-full py-2 px-4 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-colors duration-200 flex items-center justify-center space-x-2 text-sm font-semibold"
          disabled={character.isDying || character.status === 'dead'} // Disable if dying/dead
        >
          {showAddCustomWeaponForm ? <Minus className="w-4 h-4" /> : <Plus className="w-4 h-4" />}
          <span>{showAddCustomWeaponForm ? 'Hide Custom Weapon Form' : 'Add Custom Weapon/Attack'} ({character.actions.length}/{MAX_CUSTOM_WEAPONS})</span>
        </button>

        {showAddCustomWeaponForm && (
          <div className="mt-3 space-y-3">
            <input
              type="text"
              placeholder="Attack/Weapon Name"
              value={newCustomWeaponName}
              onChange={(e) => setNewCustomWeaponName(e.target.value)}
              maxLength={40} // Max length for weapon name
              className="w-full p-2 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500"
            />
            <div className="flex items-center space-x-2">
              <input
                type="number"
                min="1"
                max="100"
                value={newCustomWeaponNumDice}
                onChange={(e) => setNewCustomWeaponNumDice(Math.min(100, Math.max(1, parseInt(e.target.value) || 1)))}
                className={`w-16 p-2 rounded-lg text-center bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500
                  ${newCustomWeaponNumDice === 1 ? 'text-gray-400' : ''}`}
                placeholder="1"
              />
              <span className="text-lg font-bold text-gray-300">D</span>
              <select
                value={newCustomWeaponDieType}
                onChange={(e) => setNewCustomWeaponDieType(e.target.value)}
                className="p-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500 flex-grow"
              >
                <option value="d4">d4</option>
                <option value="d6">d6</option>
                <option value="d8">d8</option>
                <option value="d10">d10</option>
                <option value="d12">d12</option>
                <option value="d20">d20</option>
                <option value="d100">d100</option>
              </select>
              {/* Replaced input with NumberScroller for Damage Modifier */}
              <NumberScroller
                value={newCustomWeaponModifier}
                onChange={setNewCustomWeaponModifier}
                min={-20}
                max={20}
                isDefaultValueDisplay={true} // Ensure 0 is shown by default
              />
            </div>
            {/* Damage Type Dropdown */}
            <div>
              <label htmlFor="damage-type-select" className="block text-sm font-medium text-gray-300 mb-1">Damage Type</label>
              <select
                id="damage-type-select"
                value={selectedDamageTypeForNewWeapon}
                onChange={(e) => {
                  setSelectedDamageTypeForNewWeapon(e.target.value);
                  if (e.target.value !== 'Other') {
                    setCustomDamageTypeName(''); // Clear custom input if not 'Other'
                  }
                }}
                className="w-full p-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
              >
                <option value="">-- Select Damage Type --</option>
                <option value="Acid">Acid</option>
                <option value="Bludgeoning">Bludgeoning</option>
                <option value="Cold">Cold</option>
                <option value="Fire">Fire</option>
                <option value="Force">Force</option>
                <option value="Lightning">Lightning</option>
                <option value="Necrotic">Necrotic</option>
                <option value="Piercing">Piercing</option>
                <option value="Poison">Poison</option>
                <option value="Psychic">Psychic</option>
                <option value="Radiant">Radiant</option>
                <option value="Slashing">Slashing</option>
                <option value="Thunder">Thunder</option>
                <option value="Other">Other (Type Below)</option>
              </select>
            </div>
            {selectedDamageTypeForNewWeapon === 'Other' && (
              <input
                type="text"
                placeholder="Custom Damage Type"
                value={customDamageTypeName}
                onChange={(e) => setCustomDamageTypeName(e.target.value)}
                className="w-full p-2 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 mt-2"
              />
            )}
            {/* Replaced input with NumberScroller for To Hit Modifier */}
            <div className="flex items-center">
              <label htmlFor="to-hit-modifier-scroller" className="block text-sm font-medium text-gray-300 mr-2">To Hit Modifier:</label>
              <NumberScroller
                value={newCustomWeaponToHitModifier}
                onChange={setNewCustomWeaponToHitModifier}
                min={-20}
                max={20}
                isDefaultValueDisplay={true} // Ensure 0 is shown by default
              />
            </div>
            <button
              onClick={handleAddCustomWeapon}
              disabled={character.actions.length >= MAX_CUSTOM_WEAPONS}
              className={`w-full py-2 px-4 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors duration-200 mt-4
                ${character.actions.length >= MAX_CUSTOM_WEAPONS ? 'opacity-50 cursor-not-allowed' : ''}`}
            >
              Add Weapon
            </button>
          </div>
        )}
      </div>


      <button
        onClick={() => onToggleRemovedFromCombat(character.id, true)} // New function call
        className="w-full py-2 px-4 bg-gray-600 text-white rounded-xl hover:bg-gray-500 transition-colors duration-200 mt-4"
        aria-label="Remove character from combat"
      >
        <Trash2 className="inline-block mr-2 w-5 h-5" /> Remove from Combat
      </button>
    </div>
  );
};


// CharacterCard component for the simplified right-hand list
const MiniCharacterCard = ({ character, onSelectCharacter, isSelected, onUpdateColor, allColors, onUpdateHp, onToggleRemovedFromCombat, onUpdateStatus, onUpdateActionCheckbox, onUpdateCurrentMovement, onUpdateActions, addLogEntry, onUpdateCharacterName,
  newCustomWeaponName, setNewCustomWeaponName, newCustomWeaponNumDice, setNewCustomWeaponNumDice, newCustomWeaponDieType, setNewCustomWeaponDieType, newCustomWeaponModifier, setNewCustomWeaponModifier,
  selectedDamageTypeForNewWeapon, setSelectedDamageTypeForNewWeapon, customDamageTypeName, setCustomDamageTypeName, newCustomWeaponToHitModifier, setNewCustomWeaponToHitModifier,
  onTogglePanelLock, // Pass the setter for the individual character's lock state
  onUpdateAbilityRoll, // Pass the new prop for updating ability rolls
  onRollDeathSave, // NEW: Pass death save roll handler
  deathSavesEnabled, // NEW: Pass death saves enabled state
  onActivateTrait // Pass the new prop for activating traits
}) => {
  const [showColorPicker, setShowColorPicker] = useState(false);
  const cardRef = useRef(null); // Ref for the entire card, to detect clicks outside

  const handleColorCircleClick = (e) => {
    e.stopPropagation(); // Prevent selecting the character when changing color
    setShowColorPicker(!showColorPicker);
  };

  const handleColorSelected = (color) => {
    onUpdateColor(character.id, color);
    setShowColorPicker(false); // Close picker after selection
  };

  // Close color picker if anything outside the card is clicked
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (cardRef.current && !cardRef.current.contains(event.target)) {
        setShowColorPicker(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []); // Removed onClose from dependency array

  // Determine skull type
  const isRedSkull = character.isDying && (character.deathFailures >= 3 || (character.deathSaveOpportunities !== null && character.deathSaveOpportunities <= 0));
  const isWhiteSkull = character.isDying && !isRedSkull;

  // Determine turn completed indicator color
  const turnCompletedColorClass = (character.isDying || character.status === 'dead') ? 'text-red-500' : 'text-green-500';

  // Determine classes for the main card div
  const isRemovedOrDead = isRedSkull || character.removedFromCombat;
  const cardOpacityClass = isRemovedOrDead ? 'opacity-50' : '';
  const nameLineThroughClass = isRedSkull ? 'line-through' : ''; // Only apply to name


  return (
    <div className="relative"> {/* Outer div to contain card and details */}
      <div className="relative flex items-center mb-2"> {/* Added flex and items-center for alignment */}
        <div
          onClick={() => onSelectCharacter(character.id)}
          className={`flex-grow flex items-center p-3 rounded-lg shadow-md cursor-pointer transition-all duration-200
            ${isSelected ? 'bg-purple-500 text-white border-2 border-purple-300 transform scale-105' :
              'bg-gray-700 text-white hover:bg-gray-600'}
            ${cardOpacityClass}`}
        >
          <div className="flex items-center">
            <div
              className="w-6 h-6 rounded-full border-2 border-white mr-3 cursor-pointer"
              style={{ backgroundColor: character.color }}
              onClick={handleColorCircleClick}
              title="Change color"
            ></div>
            {/* Updated order: (Species) Name */}
            <span className={`font-semibold text-lg truncate ${nameLineThroughClass}`}>
              {character.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond icon for custom */}
              {character.species && <span className="text-sm text-gray-300 mr-1">({character.species})</span>}
              {character.name}
              {/* Red Skull Display */}
              {isRedSkull && (
                <Skull color="red" className="inline-block ml-2 w-5 h-5" title="Dead / Incapacitated" />
              )}
              {/* White Skull Display (Dying, making saves) - Only if death saves are enabled */}
              {isWhiteSkull && deathSavesEnabled && (
                <Skull color="white" className="inline-block ml-2 w-5 h-5" title={`Dying: Successes: ${character.deathSuccesses} / Failures: ${character.deathFailures} (Rolls Left: ${character.deathSaveOpportunities !== null ? character.deathSaveOpportunities : 'N/A'})`} />
              )}
            </span>
          </div>
          {/* Initiative value moved here, to the right of the round check button */}
          <div className="flex items-center ml-auto"> {/* Use ml-auto to push to right */}
            <span className="text-xl font-bold mr-3">{character.initiative}</span>
            {/* New Turn Completed Checkbox - replaced with icon display */}
            <div
              onClick={(e) => {
                e.stopPropagation(); // Prevent opening/closing details when clicking icon
                // Only allow toggling if not dead/dying
                if (!(character.isDying || character.status === 'dead')) {
                  onUpdateActionCheckbox(character.id, 'turnCompleted', !character.turnCompleted);
                }
              }}
              className={`ml-3 h-6 w-6 rounded-full flex items-center justify-center cursor-pointer flex-shrink-0
                ${character.turnCompleted ? turnCompletedColorClass : 'border-2 border-gray-400 text-transparent'}`}
              title={character.turnCompleted ? "Turn Completed" : "Mark Turn Completed"}
            >
              {character.turnCompleted && <Check className="w-5 h-5" />}
            </div>
            {/* Death Saving Throw Button - Only if death saves are enabled */}
            {isWhiteSkull && !character.hasMadeDeathSaveThisRound && deathSavesEnabled && (
              <button
                onClick={(e) => {
                  e.stopPropagation(); // Prevent selecting the character
                  onRollDeathSave(character.id);
                }}
                className="ml-3 py-1.5 px-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-200 text-sm font-semibold whitespace-nowrap"
                title="Roll Death Saving Throw (1 per turn)"
              >
                Roll Death Save
              </button>
            )}
          </div>
        </div>


        {showColorPicker && (
          <ColorPickerWheel
            currentColor={character.color}
            allColors={allColors}
            onSelect={handleColorSelected}
            onClose={() => setShowColorPicker(false)} // Explicitly pass onClose
          />
        )}
      </div>
      {isSelected && (
        <CombatantDetails
          character={character}
          onUpdateHp={onUpdateHp}
          onToggleRemovedFromCombat={onToggleRemovedFromCombat} // Pass the new function
          onUpdateStatus={onUpdateStatus}
          onUpdateActionCheckbox={onUpdateActionCheckbox}
          onUpdateCurrentMovement={onUpdateCurrentMovement}
          onUpdateActions={onUpdateActions} // Pass the new prop
          addLogEntry={addLogEntry} // Pass log function
          onUpdateCharacterName={onUpdateCharacterName} // Pass character name update function
          // Pass custom weapon states and setters
          newCustomWeaponName={newCustomWeaponName}
          setNewCustomWeaponName={setNewCustomWeaponName}
          newCustomWeaponNumDice={newCustomWeaponNumDice}
          setNewCustomWeaponNumDice={setNewCustomWeaponNumDice}
          newCustomWeaponDieType={newCustomWeaponDieType}
          setNewCustomWeaponDieType={setNewCustomWeaponDieType}
          newCustomWeaponModifier={newCustomWeaponModifier}
          setNewCustomWeaponModifier={setNewCustomWeaponModifier}
          selectedDamageTypeForNewWeapon={selectedDamageTypeForNewWeapon}
          setSelectedDamageTypeForNewWeapon={setSelectedDamageTypeForNewWeapon}
          customDamageTypeName={customDamageTypeName}
          setCustomDamageTypeName={setCustomDamageTypeName}
          newCustomWeaponToHitModifier={newCustomWeaponToHitModifier}
          setNewCustomWeaponToHitModifier={setNewCustomWeaponToHitModifier}
          onTogglePanelLock={onTogglePanelLock} // Pass the setter
          onUpdateAbilityRoll={onUpdateAbilityRoll} // Pass the new prop
          onActivateTrait={onActivateTrait} // Pass the new prop
        />
      )}
    </div>
  );
};

// New component for the summary list on the left
const SummaryCharacterCard = ({ character, onDragStart, onDragOver, onDrop, isDraggingOver, onToggleRemovedFromCombat, onDeleteCombatant, onRemoveAndLoot }) => {
  const [isCollapsed, setIsCollapsed] = useState(true); // New state for collapsibility

  const hpPercentage = (character.hp / character.maxHp) * 100;
  const hpColorClass = hpPercentage > 50 ? 'bg-green-500' : hpPercentage > 20 ? 'bg-yellow-500' : 'bg-red-500';

  // Determine HP bar color based on status
  const statusBarColorClass = STATUS_EFFECTS[character.status]?.colorClass || 'bg-gray-500';

  // State for toggling item panels
  const [showLootPanel, setShowLootPanel] = useState(false);
  const [showArmorPanel, setShowArmorPanel] = useState(false);
  const [showWeaponsPanel, setShowWeaponsPanel] = useState(false);

  // Filter items based on type
  const lootItems = character.items?.filter(item => item.type === 'loot' || item.type === 'potion') || [];
  const armorItems = character.items?.filter(item => item.type === 'armor') || [];
  const weaponItems = character.items?.filter(item => item.type === 'weapon') || [];

  // Determine classes based on status and drag state
  const statusClasses = character.status === 'dead'
    ? 'bg-gray-600 text-gray-400'
    : character.status === 'unconscious'
      ? 'bg-red-900 text-red-300'
      : 'bg-gray-700 text-white';

  const draggingClass = isDraggingOver ? 'border-2 border-blue-400' : '';
  const removedClass = character.removedFromCombat ? 'opacity-50' : '';

  const finalCardClasses = `p-2 mb-1 rounded-lg shadow-sm text-sm ${statusClasses} ${draggingClass} ${removedClass}`;

  // Determine if the name should be crossed out
  const isRedSkull = character.isDying && (character.deathFailures >= 3 || (character.deathSaveOpportunities !== null && character.deathSaveOpportunities <= 0));
  const nameLineThroughClass = isRedSkull ? 'line-through' : '';


  return (
    <div
      onDragOver={(e) => onDragOver(e, character.id)}
      onDrop={(e) => onDrop(e, character.id)}
      onDragLeave={(e) => { e.currentTarget.classList.remove('border-2', 'border-blue-400'); }} // Remove border on drag leave
      className={finalCardClasses}
      style={{ opacity: isDraggingOver ? 0.5 : (character.removedFromCombat ? 0.7 : 1) }} // Visual feedback for dragging over and removed status
    >
      {/* Draggable Area (Name Box) */}
      <div
        draggable="true"
        onDragStart={(e) => onDragStart(e, character.id)}
        className="p-2 rounded-md border border-gray-600 bg-gray-600 cursor-grab flex items-center justify-between"
      >
        <div className={`font-semibold text-base truncate ${nameLineThroughClass}`} style={{ color: character.color }}> {/* Apply color and line-through here */}
          {character.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond icon for custom */}
          {character.name}
          {character.species && ` (${character.species})`}
          {character.removedFromCombat && <span className="ml-2 text-xs text-gray-400">(Removed)</span>} {/* Removed indicator */}
        </div>
        {/* Status text, explicitly NOT crossed out */}
        {character.status !== 'active' && (
          <span className={`ml-2 px-2 py-0.5 rounded-full text-xs font-medium ${statusBarColorClass} text-white`}>
            {character.status.charAt(0).toUpperCase() + character.status.slice(1)}
          </span>
        )}
        {/* Icons nested inside the draggable name box */}
        {character.type === 'monster' && (
          <div className="flex space-x-1 ml-auto flex-shrink-0"> {/* ml-auto to push to right */}
            {lootItems.length > 0 && (
              <button
                onClick={(e) => { e.stopPropagation(); setShowLootPanel(!showLootPanel); }}
                className={`p-1 rounded-md text-xs font-medium transition-colors duration-200 flex items-center
                  ${showLootPanel ? 'bg-yellow-600 text-white' : 'bg-gray-500 text-gray-200 hover:bg-gray-400'}`}
                title="Toggle Loot"
              >
                <Gem className="w-4 h-4" />
              </button>
            )}
            {armorItems.length > 0 && (
              <button
                onClick={(e) => { e.stopPropagation(); setShowArmorPanel(!showArmorPanel); }}
                className={`p-1 rounded-md text-xs font-medium transition-colors duration-200 flex items-center
                  ${showArmorPanel ? 'bg-blue-600 text-white' : 'bg-gray-500 text-gray-200 hover:bg-gray-400'}`}
                title="Toggle Armor"
              >
                <Shirt className="w-4 h-4" />
              </button>
            )}
            {weaponItems.length > 0 && (
              <button
                onClick={(e) => { e.stopPropagation(); setShowWeaponsPanel(!showWeaponsPanel); }}
                className={`p-1 rounded-md text-xs font-medium transition-colors duration-200 flex items-center
                  ${showWeaponsPanel ? 'bg-red-600 text-white' : 'bg-gray-500 text-gray-200 hover:bg-gray-400'}`}
                title="Toggle Weapons"
              >
                <Sword className="w-4 h-4" />
              </button>
            )}
          </div>
        )}
        {/* Collapsible Toggle */}
        <button
          onClick={(e) => { e.stopPropagation(); setIsCollapsed(!isCollapsed); }}
          className="p-1 rounded-full bg-gray-500 hover:bg-gray-400 transition-colors duration-200 ml-2 flex-shrink-0"
          title={isCollapsed ? "Expand Details" : "Collapse Details"}
        >
          {isCollapsed ? <ChevronDown className="w-4 h-4" /> : <ChevronUp className="w-4 h-4" />}
        </button>
      </div>

      {/* Always visible stats */}
      <div className="flex flex-wrap text-xs text-gray-300 mt-1">
        <span className="mr-2">AC: {character.ac || 'N/A'}</span>
        <span className="mr-2">HP: {character.hp}/{character.maxHp}</span>
        <span className="mr-2">Mvmt: {character.movement || 'N/A'}</span>
        {character.xp !== undefined && <span className="mr-2">XP: {character.xp}</span>} {/* Display XP */}
      </div>
      <div className="w-full bg-gray-300 rounded-full h-1.5 mt-1">
        <div className={`${statusBarColorClass} h-1.5 rounded-full`} style={{ width: `${hpPercentage}%` }}></div>
      </div>

      {/* Collapsible Content */}
      <div className={`transition-all duration-300 ease-in-out overflow-hidden ${isCollapsed ? 'max-h-0' : 'max-h-[500px]'}`}> {/* Max height for smooth transition */}
        <div className="mt-2">
          {/* New: Monster Skills, Senses, Languages, Proficiency Bonus */}
          {character.type === 'monster' && (
            <div className="mt-2 p-2 bg-gray-800 rounded-md border border-gray-700 text-gray-200">
              <h4 className="font-semibold text-gray-300 mb-1">Details:</h4>
              <ul className="list-disc list-inside text-xs space-y-0.5">
                {character.proficiencyBonus !== undefined && (
                  <li>Proficiency Bonus: {character.proficiencyBonus >= 0 ? `+${character.proficiencyBonus}` : character.proficiencyBonus}</li>
                )}
                {character.skills && Object.keys(character.skills).length > 0 && (
                  <li>
                    Skills: {Object.entries(character.skills).map(([skill, bonus]) => `${skill} ${bonus}`).join(', ')}
                  </li>
                )}
                {character.senses && <li>Senses: {character.senses}</li>}
                {character.languages && <li>Languages: {character.languages}</li>}
              </ul>
            </div>
          )}

          {/* Item Panels (conditionally rendered) */}
          {showLootPanel && lootItems.length > 0 && (
            <div className="mt-2 p-2 bg-gray-800 rounded-md border border-yellow-700 text-gray-200">
              <h4 className="font-semibold text-yellow-300 mb-1">Loot:</h4>
              <ul className="list-disc list-inside text-xs space-y-0.5">
                {lootItems.map((item, idx) => (
                  <li key={idx}>
                    {item.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond for custom items */}
                    {item.name} {item.quantity ? `(${item.quantity} ${item.unit})` : ''} {item.effect ? `(${item.effect})` : ''}
                  </li>
                ))}
              </ul>
            </div>
          )}
          {showArmorPanel && armorItems.length > 0 && (
            <div className="mt-2 p-2 bg-gray-800 rounded-md border border-blue-700 text-gray-200">
              <h4 className="font-semibold text-blue-300 mb-1">Armor:</h4>
              <ul className="list-disc list-inside text-xs space-y-0.5">
                {armorItems.map((item, idx) => (
                  <li key={idx}>
                    {item.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond for custom items */}
                    {item.name} (AC: {item.ac}, Type: {item.armorType})
                  </li>
                ))}
              </ul>
            </div>
          )}
          {showWeaponsPanel && weaponItems.length > 0 && (
            <div className="mt-2 p-2 bg-gray-800 rounded-md border border-red-700 text-gray-200">
              <h4 className="font-semibold text-red-300 mb-1">Weapons:</h4>
              <ul className="list-disc list-inside text-xs space-y-0.5">
                {weaponItems.map((item, idx) => (
                  <li key={idx}>
                    {item.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond for custom items */}
                    {item.name} (Dmg: {item.damage} {item.damageType ? ` ${item.damageType}` : ''}{item.toHit ? `, To Hit: ${item.toHit}` : ''})
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>


        {/* Action Buttons (visible when expanded) */}
        <div className="mt-4 flex flex-col space-y-2">
          {character.removedFromCombat && (
            <button
              onClick={() => onToggleRemovedFromCombat(character.id, false)}
              className="w-full py-1.5 px-3 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 transition-colors duration-200 text-xs flex items-center justify-center space-x-1"
            >
              <RotateCcw className="w-3 h-3" />
              <span>Restore to Combat</span>
            </button>
          )}
          <button
            onClick={() => onRemoveAndLoot(character.id)}
            className="w-full py-1.5 px-3 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors duration-200 text-xs flex items-center justify-center space-x-1"
          >
            <Gem className="w-3 h-3" />
            <span>Remove & Loot Items</span>
          </button>
          <button
            onClick={() => onDeleteCombatant(character.id)}
            className="w-full py-1.5 px-3 bg-gray-900 text-white rounded-md hover:bg-gray-700 transition-colors duration-200 text-xs flex items-center justify-center space-x-1"
          >
            <Trash2 className="w-3 h-3" />
            <span>Delete Combatant</span>
          </button>
        </div>
      </div>
    </div>
  );
};

// Main App component
const App = () => {
  const [characters, setCharacters] = useState([]);
  const [newCharacterName, setNewCharacterName] = useState('');
  const [newCharacterInitiative, setNewCharacterInitiative] = useState(''); // Stores the total initiative
  const [monsterInitiativeMathDisplay, setMonsterInitiativeMathDisplay] = useState(''); // Stores "d20 roll" for display
  const [newCharacterHp, setNewCharacterHp] = useState('1'); // Default to '1' for NumberScroller
  const [newCharacterAc, setNewCharacterAc] = useState('0'); // Default to '0' for NumberScroller
  const [newCharacterHpDice, setNewCharacterHpDice] = useState(''); // XdY part of HP dice
  const [newCharacterHpModifier, setNewCharacterHpModifier] = useState(''); // Modifier part of HP dice
  const [newCharacterHpBaseRollDisplay, setNewCharacterHpBaseRollDisplay] = useState(''); // New state for HP base roll display
  const [newCharacterMovement, setNewCharacterMovement] = useState('0'); // New state for movement, default to '0'
  const [newCharacterActions, setNewCharacterActions] = useState(''); // New state for actions (comma-separated)
  const [newCharacterType, setNewCharacterType] = useState('player');
  const [showAddForm, setShowAddForm] = useState(false);
  const [selectedMonsterId, setSelectedMonsterId] = useState('');
  const [monsterSortOption, setMonsterSortOption] = useState('name');
  // Changed selectedCombatantId to a Set to allow multiple open detail panels
  const [openCombatantIds, setOpenCombatantIds] = useState(new Set());
  const [newCharacterQuantity, setNewCharacterQuantity] = useState('1'); // Changed to '1' for NumberScroller default

  // New states for randomization checkboxes
  const [randomizeAc, setRandomizeAc] = useState(false);
  const [randomizeWeapons, setRandomizeWeapons] = useState(false);
  const [createUniqueNames, setCreateUniqueNames] = useState(false);
  const [sharedInitiative, setSharedInitiative] = useState(true); // New state for shared initiative, default true
  const [rollHpOnAddBatch, setRollHpOnAddBatch] = useState(false); // New state for rolling HP on batch add
  const [randomizeNewCombatantStats, setRandomizeNewCombatantStats] = useState(false); // New state for randomizing all 6 stats

  // New states for player ability scores
  const [newCharacterStr, setNewCharacterStr] = useState('');
  const [newCharacterDex, setNewCharacterDex] = useState('');
  const [newCharacterCon, setNewCharacterCon] = useState('');
  const [newCharacterInt, setNewCharacterInt] = useState('');
  const [newCharacterWis, setNewCharacterWis] = useState('');
  const [newCharacterCha, setNewCharacterCha] = useState('');

  // State for "All Combatants Overview" collapsibility
  const [isOverviewCollapsed, setIsOverviewCollapsed] = useState(false);


  // State to track the next color index for sequential assignment
  const [nextColorIndex, setNextColorIndex] = useState(0);

  // Combat Log states
  const [logEntries, setLogEntries] = useState([]);
  const [showLog, setShowLog] = useState(false);
  const logRef = useRef(null); // Ref for scrolling log to bottom

  // Global states for Custom Weapon inputs (lifted from CombatantDetails)
  const [newCustomWeaponName, setNewCustomWeaponName] = useState('');
  const [newCustomWeaponNumDice, setNewCustomWeaponNumDice] = useState(1);
  const [newCustomWeaponDieType, setNewCustomWeaponDieType] = useState('d4');
  const [newCustomWeaponModifier, setNewCustomWeaponModifier] = useState('0'); // Default to '0'
  const [selectedDamageTypeForNewWeapon, setSelectedDamageTypeForNewWeapon] = useState(''); // New state for dropdown
  const [customDamageTypeName, setCustomDamageTypeName] = useState(''); // New state for custom input
  const [newCustomWeaponToHitModifier, setNewCustomWeaponToHitModifier] = useState('0'); // Default to '0'

  // State to keep track of used unique names to prevent repetition
  const [usedUniqueNames] = useState(new Set()); // Changed to useState for proper state management

  // State for monster initiative roll display (removed monsterD20Roll, now part of monsterInitiativeMathDisplay)
  const [currentMonsterInitiativeBonus, setCurrentMonsterInitiativeBonus] = useState(0);

  // Drag and Drop states for "All Combatants Overview"
  const [draggedItemId, setDraggedItemId] = useState(null);
  const [dragOverItemId, setDragOverItemId] = useState(null);

  // NEW: Round Counter
  const [round, setRound] = useState(1);

  // NEW: Current Initiative Index for turn tracking (though not explicitly used for turn highlighting yet)
  const [currentInitiativeIndex, setCurrentInitiativeIndex] = useState(0);

  // NEW: Death Saves Toggle
  const [deathSavesEnabled, setDeathSavesEnabled] = useState(false); // Default to false

  // NEW: Loot Pool state
  const [lootPool, setLootPool] = useState([]);
  const [totalXpPool, setTotalXpPool] = useState(0); // New state for total XP
  const [showLootPool, setShowLootPool] = useState(false);

  // NEW: Undo List states
  const [deletedCharacters, setDeletedCharacters] = useState([]);
  const [showUndoList, setShowUndoList] = useState(false);
  const MAX_UNDO_BUFFER = 20; // Max characters in undo list


  const MAX_TOTAL_COMBATANTS = 40;
  const MAX_ADD_QUANTITY = 20;

  // Define the 12-color palette
  const COLORS = useMemo(() => [
    '#FF0000', // Red
    '#FF7F00', // Orange
    '#FFFF00', // Yellow
    '#7FFF00', // Chartreuse Green
    '#00FF00', // Green
    '#00FF7F', // Spring Green
    '#00FFFF', // Cyan
    '#007FFF', // Azure
    '#0000FF', // Blue
    '#7F00FF', // Violet
    '#FF00FF', // Magenta
    '#FF007F', // Rose
  ], []);

  // Function to add a log entry
  const addLogEntry = useCallback(({ type, characterId, message, value, details, isCrit, hpChangeType }) => {
    setLogEntries(prevEntries => [
      ...prevEntries,
      { timestamp: new Date(), type, characterId, message, value, details, isCrit, hpChangeType }
    ]);
  }, []);

  // Scroll log to bottom when new entries are added
  useEffect(() => {
    if (logRef.current) {
      logRef.current.scrollTop = logRef.current.scrollHeight;
    }
  }, [logEntries]);

  // Name data for unique naming
  const namesData = useMemo(() => ({
    human: {
      first: ["Aric", "Bryn", "Cael", "Elara", "Finn", "Gareth", "Isolde", "Kaelen", "Lyra", "Milo", "Niamh", "Orin", "Pippa", "Quinn", "Rowan", "Seraphina", "Thorne", "Una", "Vance", "Willow"],
      last: ["Blackwood", "Stone", "Fairwind", "Ironhide", "Swift", "Brightblade", "Shadowbrook", "Strongarm", "Deepriver", "Lightfoot", "Grimfang", "Sunstrider", "Whisperwind", "Stonemarch", "Goldhand", "Moonwhisper", "Trueheart", "Wilder", "Frostbeard", "Fireforge"]
    },
    elf: {
      first: ["Aerion", "Faelar", "Glimmer", "Illyana", "Lirael", "Mithrandir", "Nym", "Oriana", "Silvanus", "Thranduil", "Valen", "Zephyr", "Aeliana", "Eldrin", "Feyra", "Galad", "Lyra", "Nimrodel", "Sylas", "Vanya"],
      last: ["Moonwhisper", "Starfall", "Shadowleaf", "Riverlight", "Whisperwind", "Everhart", "Nightshade", "Sunstrider", "Deepwood", "Silverstream", "Brightarrow", "Truebow", "Stardancer", "Forestheart", "Gemflower", "Lightwing", "Greensong", "Swiftfoot", "Windrider", "Mistwalker"]
    },
    dwarf: {
      first: ["Borin", "Durin", "Gimli", "Hilda", "Kael", "Magnus", "Odin", "Thrain", "Volk", "Yara", "Bronn", "Dagna", "Grak", "Helga", "Korgan", "Murdin", "Olga", "Thorek", "Vali", "Yngvar"],
      last: ["Stonebeard", "Ironfist", "Deepdelver", "Hammerfall", "Rockshield", "Goldaxe", "Bouldergrip", "Strongpick", "Coalhammer", "Steelheart", "Grimeye", "Anvilhand", "Orebelly", "Granitefoot", "Runesmith", "Darkiron", "Cinderbeard", "Stonebrow", "Brewbarrel", "Fellhammer"]
    },
    orc: {
      first: ["Grak", "Thorg", "Urza", "Zog", "Grish", "Snarl", "Mog", "Klarg", "Drog", "Vrak", "Horg", "Ragnuk", "Skarg", "Grognak", "Murdok", "Grum", "Bonecrunch", "Bloodaxe", "Gutripper", "Ironhide"],
      last: ["Skullsplitter", "Bloodfang", "Ironjaw", "Bonebreaker", "Grimaxe", "Shadowhide", "Stonefist", "Blacktooth", "Redeye", "Spinecrusher", "Gutrender", "Fleshripper", "Rockfist", "Wargrider", "Goretooth", "Savageblade", "Rageheart", "Deathbringer", "Stormcaller", "Earthshaker"]
    },
    goblin: {
      first: ["Snik", "Grub", "Fizz", "Wort", "Mog", "Pox", "Stink", "Grib", "Flick", "Snarl", "Rik", "Zog", "Kik", "Blink", "Drip", "Squint", "Twitch", "Glim", "Nox", "Pip"],
      last: ["Stabber", "Sneak", "Grime", "Pustule", "Wartnose", "Scurry", "Quickfinger", "Mudfoot", "Shadowhide", "Backstab", "Greenskin", "Rustblade", "Caveborn", "Dirtfoot", "Webspinner", "Foulbreath", "Nighteye", "Stonehide", "Gutterfang", "Slimefoot"]
    },
    skeleton: {
      first: ["Clatter", "Rattle", "Bone", "Shank", "Grave", "Dust", "Husk", "Wither", "Echo", "Shade", "Grim", "Silent", "Hollow", "Creak", "Ancient", "Pale", "Whisper", "Stiff", "Crumble", "Lost"],
      last: ["Bones", "Rattler", "Shambler", "Crypt", "Wight", "Dusty", "Hollow", "Grim", "Silent", "Echo", "Grave", "Pale", "Whisper", "Stiff", "Crumble", "Lost", "Wither", "Shade", "Ancient", "Forgotten"]
    },
    zombie: {
      first: ["Groan", "Stumble", "Rot", "Pus", "Grave", "Dread", "Shamble", "Lurch", "Maw", "Stench", "Flesh", "Decay", "Hunger", "Mould", "Slime", "Corpse", "Reek", "Drunk", "Slow", "Dumb"],
      last: ["Walker", "Rotter", "Stumbler", "Graveborn", "Dreadful", "Shambler", "Lurcher", "Maw", "Stench", "Flesh", "Decay", "Hunger", "Mould", "Slime", "Corpse", "Reek", "Drunk", "Slow", "Dumb", "Mindless"]
    },
    dragon: {
      first: ["Ignis", "Aura", "Cinder", "Drakon", "Fafnir", "Glaurung", "Harkon", "Ignis", "Jormungandr", "Kaelen", "Lava", "Malakor", "Nidhogg", "Onyx", "Pyre", "Quill", "Ragnar", "Smaug", "Tiamat", "Urth"],
      last: [] // Last names not used for "X the Dragon" format
    },
    elemental: {
      first: ["Ignis", "Storm", "Terra", "Aqua", "Cinder", "Gale", "Stone", "Torrent", "Spark", "Quake", "Mist", "Blaze", "Boulder", "Riptide", "Zephyr", "Dust", "Frost", "Magma", "Vortex", "Breeze"],
      last: [] // Last names not used for "X the Elemental" format
    },
  }), []);


  // Simulated monster data (with movement and actions)
  const allMonsters = useMemo(() => [
    { id: 'goblin', name: 'Goblin', species: 'Goblin', size: 'Small', hp: 7, ac: 15, cr: '1/4', xp: 50, hpDice: '2d6', initiativeBonus: 2, movement: '30ft', actions: [{name: 'Scimitar Attack', dice: '1d6+2', damageType: 'Slashing', toHitModifier: 4}, {name: 'Shortbow Attack', dice: '1d6+1', damageType: 'Piercing', toHitModifier: 4}], str: 8, dex: 14, con: 10, int: 10, wis: 8, cha: 8,
      proficiencyBonus: 2, skills: { Stealth: '+6', Perception: '+1' }, senses: 'Darkvision 60 ft., Passive Perception 11', languages: 'Common, Goblin',
      items: [
        { type: 'weapon', name: 'Scimitar', damage: '1d6', damageType: 'Slashing', toHit: '+4' },
        { type: 'weapon', name: 'Shortbow', damage: '1d6', damageType: 'Piercing', toHit: '+4' },
        { type: 'armor', name: 'Leather Armor', ac: 11, armorType: 'Light' },
        { type: 'loot', name: '2d4 cp', quantity: '2d4', unit: 'cp' },
        { type: 'loot', name: '1d6 sp', quantity: '1d6', unit: 'sp' },
        { type: 'loot', name: 'Goblin Ear' },
      ],
      traits: [
        { id: 'nimble_escape', name: 'Nimble Escape', description: 'Can take the Disengage or Hide action as a bonus action on each of its turns.', actionType: 'bonusAction' },
      ]
    },
    { id: 'orc', name: 'Orc', species: 'Orc', size: 'Medium', hp: 15, ac: 13, cr: '1/2', xp: 100, hpDice: '2d8+6', initiativeBonus: 0, movement: '30ft', actions: [{name: 'Greataxe Attack', dice: '1d12+3', damageType: 'Slashing', toHitModifier: 5}, {name: 'Javelin Attack', dice: '1d6+3', damageType: 'Piercing', toHitModifier: 5}], str: 16, dex: 12, con: 16, int: 7, wis: 11, cha: 10,
      proficiencyBonus: 2, skills: { Intimidation: '+2' }, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Common, Orc',
      items: [
        { type: 'weapon', name: 'Greataxe', damage: '1d12', damageType: 'Slashing', toHit: '+5' },
        { type: 'weapon', name: 'Javelin', damage: '1d6', damageType: 'Piercing', toHit: '+5' },
        { type: 'armor', name: 'Hide Armor', ac: 12, armorType: 'Medium' },
        { type: 'loot', name: '5 gp', quantity: '5', unit: 'gp' },
        { type: 'loot', name: 'Orc Tooth' },
      ],
      traits: [
        { id: 'aggressive', name: 'Aggressive', description: 'As a bonus action, the orc can move up to its speed toward a hostile creature that it can see.', actionType: 'bonusAction' },
        { id: 'relentless_endurance', name: 'Relentless Endurance', description: 'When the orc is reduced to 0 hit points but not killed outright, it can drop to 1 hit point instead. It can\'t use this feature again until it finishes a long rest.', actionType: 'passive' },
      ]
    },
    { id: 'bugbear', name: 'Bugbear', species: 'Bugbear', size: 'Medium', hp: 27, ac: 16, cr: '1', xp: 200, hpDice: '5d8+5', initiativeBonus: 2, movement: '30ft', actions: [{name: 'Morningstar Attack', dice: '2d8+3', damageType: 'Piercing', toHitModifier: 5}, {name: 'Javelin Attack', dice: '1d6+3', damageType: 'Piercing', toHitModifier: 5}], str: 15, dex: 14, con: 13, int: 8, wis: 11, cha: 9,
      proficiencyBonus: 2, skills: { Stealth: '+6', Survival: '+2' }, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Common, Goblin',
      items: [
        { type: 'weapon', name: 'Morningstar', damage: '2d8', damageType: 'Piercing', toHit: '+5' },
        { type: 'weapon', name: 'Javelin', damage: '1d6', damageType: 'Piercing', toHit: '+5' },
        { type: 'armor', name: 'Scale Mail', ac: 14, armorType: 'Medium' },
        { type: 'loot', name: '1d10 gp', quantity: '1d10', unit: 'gp' },
        { type: 'loot', name: 'Bugbear Hide' },
      ],
      traits: [
        { id: 'surprise_attack', name: 'Surprise Attack', description: 'If the bugbear surprises a creature and hits it with an attack during the first round of combat, the target takes an extra 2d6 damage from the attack.', actionType: 'passive' },
        { id: 'brute', name: 'Brute', description: 'A melee weapon deals one extra die of its damage when the bugbear hits with it (included in the attack).', actionType: 'passive' },
      ]
    },
    { id: 'direwolf', name: 'Dire Wolf', species: 'Wolf', size: 'Large', hp: 37, ac: 14, cr: '1', xp: 200, hpDice: '5d10+10', initiativeBonus: 2, movement: '50ft', actions: [{name: 'Bite', dice: '2d6+3', damageType: 'Piercing', toHitModifier: 5}], str: 17, dex: 15, con: 15, int: 3, wis: 12, cha: 7,
      proficiencyBonus: 2, skills: { Perception: '+3', Stealth: '+4' }, senses: 'Passive Perception 13', languages: '—',
      items: [
        { type: 'loot', name: 'Dire Wolf Pelt', value: '25 gp' },
        { type: 'loot', name: 'Dire Wolf Fang' },
      ],
      traits: [
        { id: 'keen_hearing_and_smell', name: 'Keen Hearing and Smell', description: 'The wolf has advantage on Wisdom (Perception) checks that rely on hearing or smell.', actionType: 'passive' },
        { id: 'pack_tactics', name: 'Pack Tactics', description: 'The wolf has advantage on an attack roll against a creature if at least one of the wolf\'s allies is within 5 feet of the creature and the ally isn\'t incapacitated.', actionType: 'passive' },
      ]
    },
    { id: 'ogre', name: 'Ogre', species: 'Ogre', size: 'Large', hp: 59, ac: 11, cr: '2', xp: 450, hpDice: '7d10+21', initiativeBonus: -1, movement: '40ft', actions: [{name: 'Greatclub Attack', dice: '2d8+4', damageType: 'Bludgeoning', toHitModifier: 6}, {name: 'Javelin Attack', dice: '1d6+4', damageType: 'Piercing', toHitModifier: 6}], str: 19, dex: 8, con: 16, int: 5, wis: 7, cha: 7,
      proficiencyBonus: 2, skills: { Athletics: '+6' }, senses: 'Darkvision 60 ft., Passive Perception 8', languages: 'Common, Giant',
      items: [
        { type: 'weapon', name: 'Greatclub', damage: '2d8', damageType: 'Bludgeoning', toHit: '+6' },
        { type: 'weapon', name: 'Javelin', damage: '1d6', damageType: 'Piercing', toHit: '+6' },
        { type: 'armor', name: 'Hide Armor (Ogre-sized)', ac: 12, armorType: 'Medium' },
        { type: 'loot', name: '2d20 gp', quantity: '2d20', unit: 'gp' },
        { type: 'loot', name: 'Ogre\'s Belt' },
      ],
      traits: [] // No special traits for Ogre in this example
    },
    { id: 'dragon_wyrmling_red', name: 'Red Dragon Wyrmling', species: 'Dragon', size: 'Medium', hp: 75, ac: 17, cr: '4', xp: 1100, hpDice: '10d8+30', initiativeBonus: 2, movement: '30ft, Fly 60ft', actions: [{name: 'Bite', dice: '1d10+4', damageType: 'Piercing', toHitModifier: 6}, {name: 'Fire Breath', dice: '6d6', damageType: 'Fire'}], str: 19, dex: 10, con: 17, int: 12, wis: 11, cha: 15,
      proficiencyBonus: 2, skills: { Perception: '+4', Stealth: '+2' }, senses: 'Blindsight 10 ft., Darkvision 60 ft., Passive Perception 14', languages: 'Draconic',
      items: [
        { type: 'loot', name: '100 gp', quantity: '100', unit: 'gp' },
        { type: 'loot', name: 'Small Ruby', value: '50 gp' },
        { type: 'loot', name: 'Dragon Scale' },
      ],
      traits: [
        { id: 'legendary_resistance', name: 'Legendary Resistance (3/Day)', description: 'If the dragon fails a saving throw, it can choose to succeed instead.', actionType: 'passive' },
      ]
    },
    { id: 'hobgoblin', name: 'Hobgoblin', species: 'Hobgoblin', size: 'Medium', hp: 11, ac: 18, cr: '1/2', xp: 100, hpDice: '2d8+2', initiativeBonus: 0, movement: '30ft', actions: [{name: 'Longsword Attack', dice: '1d8+1', damageType: 'Slashing', toHitModifier: 3}, {name: 'Longbow Attack', dice: '1d8+1', damageType: 'Piercing', toHitModifier: 3}], str: 13, dex: 12, con: 12, int: 10, wis: 10, cha: 9,
      proficiencyBonus: 2, skills: { Athletics: '+3', Stealth: '+3' }, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Common, Goblin',
      items: [
        { type: 'weapon', name: 'Longsword', damage: '1d8', damageType: 'Slashing', toHit: '+3' },
        { type: 'weapon', name: 'Longbow', damage: '1d8', damageType: 'Piercing', toHit: '+3' },
        { type: 'armor', name: 'Chain Mail', ac: 16, armorType: 'Heavy' },
        { type: 'loot', name: '1d6 gp', quantity: '1d6', unit: 'gp' },
      ],
      traits: [
        { id: 'martial_advantage', name: 'Martial Advantage', description: 'Once per turn, if the hobgoblin hits a creature with a weapon attack and that creature is within 5 feet of an ally of the hobgoblin that isn\'t incapacitated, the hobgoblin can deal an extra 2d6 damage to the creature.', actionType: 'passive' },
      ]
    },
    { id: 'skeleton', name: 'Skeleton', species: 'Undead', size: 'Medium', hp: 13, ac: 13, cr: '1/4', xp: 50, hpDice: '2d8+4', initiativeBonus: 2, movement: '30ft', actions: [{name: 'Shortsword Attack', dice: '1d6+2', damageType: 'Piercing', toHitModifier: 4}, {name: 'Shortbow Attack', dice: '1d6+2', damageType: 'Piercing', toHitModifier: 4}], str: 10, dex: 14, con: 15, int: 6, wis: 8, cha: 5,
      proficiencyBonus: 2, senses: 'Darkvision 60 ft., Passive Perception 9', languages: 'Understands Common but can\'t speak',
      items: [
        { type: 'weapon', name: 'Shortsword', damage: '1d6', damageType: 'Piercing', toHit: '+4' },
        { type: 'weapon', name: 'Shortbow', damage: '1d6', damageType: 'Piercing', toHit: '+4' },
        { type: 'armor', name: 'Shield', ac: 2, armorType: 'Shield' },
        { type: 'loot', name: 'Rusty Key' },
      ],
      traits: []
    },
    { id: 'zombie', name: 'Zombie', species: 'Undead', size: 'Medium', hp: 22, ac: 8, cr: '1/4', xp: 50, hpDice: '3d8+9', initiativeBonus: -2, movement: '20ft', actions: [{name: 'Slam', dice: '1d6+1', damageType: 'Bludgeoning', toHitModifier: 3}], str: 13, dex: 6, con: 16, int: 3, wis: 6, cha: 5,
      proficiencyBonus: 2, senses: 'Darkvision 60 ft., Passive Perception 8', languages: 'Understands Common but can\'t speak',
      items: [
        { type: 'loot', name: 'Rotten Flesh' },
      ],
      traits: [
        { id: 'undead_fortitude', name: 'Undead Fortitude', description: 'If damage reduces the zombie to 0 hit points, it must make a Constitution saving throw with a DC of 5 + the damage taken, unless the damage is radiant or from a critical hit. On a success, the zombie drops to 1 hit point instead. It can\'t use this feature again until it finishes a long rest.', actionType: 'passive' },
      ]
    },
    { id: 'giant_spider', name: 'Giant Spider', species: 'Beast', size: 'Large', hp: 26, ac: 14, cr: '1', xp: 200, hpDice: '5d8+5', initiativeBonus: 3, movement: '30ft, Climb 30ft', actions: [{name: 'Bite (Poison)', dice: '1d8+3', damageType: 'Piercing'}], str: 14, dex: 16, con: 12, int: 2, wis: 10, cha: 4,
      proficiencyBonus: 2, skills: { Stealth: '+7', Perception: '+2' }, senses: 'Blindsight 10 ft., Darkvision 60 ft., Passive Perception 12', languages: '—',
      items: [
        { type: 'loot', name: 'Giant Spider Silk', value: '10 gp' },
        { type: 'loot', name: 'Poison Gland' },
      ],
      traits: [
        { id: 'spider_climb', name: 'Spider Climb', description: 'The spider can climb difficult surfaces, including upside down on ceilings, without needing to make an ability check.', actionType: 'passive' },
        { id: 'web_sense', name: 'Web Sense', description: 'While in contact with a web, the spider knows the exact location of any other creature in contact with the same web.', actionType: 'passive' },
        { id: 'web_walker', name: 'Web Walker', description: 'The spider ignores movement restrictions caused by webbing.', actionType: 'passive' },
      ]
    },
    { id: 'owlbear', name: 'Owlbear', species: 'Monstrosity', size: 'Large', hp: 59, ac: 13, cr: '3', xp: 700, hpDice: '7d10+21', initiativeBonus: 1, movement: '40ft', actions: [{name: 'Beak', dice: '1d10+5', damageType: 'Piercing', toHitModifier: 7}, {name: 'Claws', dice: '2d8+5', damageType: 'Slashing', toHitModifier: 7}], str: 20, dex: 12, con: 17, int: 3, wis: 12, cha: 7,
      proficiencyBonus: 2, skills: { Perception: '+3' }, senses: 'Darkvision 60 ft., Passive Perception 13', languages: '—',
      items: [
        { type: 'loot', name: 'Owlbear Feather', value: '5 gp' },
        { type: 'loot', name: 'Owlbear Claw' },
      ],
      traits: [
        { id: 'keen_sight_and_smell', name: 'Keen Sight and Smell', description: 'The owlbear has advantage on Wisdom (Perception) checks that rely on sight or smell.', actionType: 'passive' },
      ]
    },
    { id: 'minotaur', name: 'Minotaur', species: 'Monstrosity', size: 'Large', hp: 76, ac: 14, cr: '3', xp: 700, hpDice: '9d10+27', initiativeBonus: 0, movement: '40ft', actions: [{name: 'Greataxe Attack', dice: '2d12+4', damageType: 'Slashing', toHitModifier: 6}, {name: 'Gore', dice: '2d8+4', damageType: 'Piercing', toHitModifier: 6}], str: 18, dex: 11, con: 16, int: 6, wis: 10, cha: 9,
      proficiencyBonus: 2, skills: { Perception: '+2' }, senses: 'Darkvision 60 ft., Passive Perception 12', languages: 'Abyssal',
      items: [
        { type: 'weapon', name: 'Greataxe', damage: '2d12', damageType: 'Slashing', toHit: '+6' },
        { type: 'loot', name: 'Minotaur Horn', value: '50 gp' },
      ],
      traits: [
        { id: 'charge', name: 'Charge', description: 'If the minotaur moves at least 10 feet straight toward a target and then hits it with a gore attack on the same turn, the target takes an extra 1d8 piercing damage. If the target is a creature, it must succeed on a DC 14 Strength saving throw or be pushed up to 10 feet away and knocked prone.', actionType: 'passive' },
        { id: 'labyrinthine_recall', name: 'Labyrinthine Recall', description: 'The minotaur can perfectly recall any path it has traveled, and it can\'t be lost in a maze.', actionType: 'passive' },
      ]
    },
    { id: 'ettin', name: 'Ettin', species: 'Giant', size: 'Large', hp: 85, ac: 12, cr: '4', xp: 1100, hpDice: '10d10+30', initiativeBonus: -1, movement: '40ft', actions: [{name: 'Greataxe (Left Head)', dice: '2d12+4', damageType: 'Slashing', toHitModifier: 7}, {name: 'Greataxe (Right Head)', dice: '2d12+4', damageType: 'Slashing', toHitModifier: 7}], str: 21, dex: 8, con: 17, int: 6, wis: 10, cha: 8,
      proficiencyBonus: 2, skills: { Perception: '+4' }, senses: 'Darkvision 60 ft., Passive Perception 14', languages: 'Giant, Orc',
      items: [
        { type: 'weapon', name: 'Greataxe', damage: '2d12', damageType: 'Slashing', toHit: '+7' },
        { type: 'loot', name: 'Ettin Skull', value: '20 gp' },
      ],
      traits: [
        { id: 'two_heads', name: 'Two Heads', description: 'The ettin has advantage on Wisdom (Perception) checks and on saving throws against being blinded, charmed, deafened, frightened, stunned, or knocked unconscious.', actionType: 'passive' },
      ]
    },
    { id: 'hill_giant', name: 'Hill Giant', species: 'Giant', size: 'Huge', hp: 105, ac: 13, cr: '5', xp: 1800, hpDice: '10d12+40', initiativeBonus: -1, movement: '40ft', actions: [{name: 'Greatclub Attack', dice: '3d8+6', damageType: 'Bludgeoning', toHitModifier: 8}, {name: 'Rock Attack', dice: '2d10+6', damageType: 'Bludgeoning', toHitModifier: 8}], str: 21, dex: 8, con: 19, int: 5, wis: 9, cha: 6,
      proficiencyBonus: 3, skills: { Athletics: '+9', Perception: '+3' }, senses: 'Passive Perception 9', languages: 'Giant',
      items: [
        { type: 'weapon', name: 'Greatclub', damage: '3d8', damageType: 'Bludgeoning', toHit: '+8' },
        { type: 'loot', name: 'Giant\'s Club' },
        { type: 'loot', name: '1d100 gp', quantity: '1d100', unit: 'gp' },
      ],
      traits: []
    },
    { id: 'dragon_wyrmling_red_adult', name: 'Adult Red Dragon Wyrmling', species: 'Dragon', size: 'Large', hp: 75, ac: 17, cr: '4', xp: 1100, hpDice: '10d8+30', initiativeBonus: 2, movement: '30ft, Fly 60ft', actions: [{name: 'Bite', dice: '1d10+4', damageType: 'Piercing', toHitModifier: 6}, {name: 'Fire Breath', dice: '6d6', damageType: 'Fire'}], str: 19, dex: 10, con: 17, int: 12, wis: 11, cha: 15,
      proficiencyBonus: 2, skills: { Perception: '+4', Stealth: '+2' }, senses: 'Blindsight 10 ft., Darkvision 60 ft., Passive Perception 14', languages: 'Draconic',
      items: [
        { type: 'loot', name: '100 gp', quantity: '100', unit: 'gp' },
        { type: 'loot', name: 'Small Ruby', value: '50 gp' },
        { type: 'loot', name: 'Dragon Scale' },
      ],
      traits: [
        { id: 'legendary_resistance', name: 'Legendary Resistance (3/Day)', description: 'If the dragon fails a saving throw, it can choose to succeed instead.', actionType: 'passive' },
      ]
    },
    { id: 'hobgoblin_captain', name: 'Hobgoblin Captain', species: 'Hobgoblin', size: 'Medium', hp: 39, ac: 17, cr: '3', xp: 700, hpDice: '6d8+12', initiativeBonus: 1, movement: '30ft', actions: [{name: 'Greatsword', dice: '2d6+2', damageType: 'Slashing', toHitModifier: 5}, {name: 'Javelin', dice: '1d6+2', damageType: 'Piercing', toHitModifier: 5}, {name: 'Parry (Bonus Action)'}], str: 15, dex: 14, con: 14, int: 12, wis: 10, cha: 13,
      proficiencyBonus: 2, skills: { Athletics: '+4', Persuasion: '+3' }, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Common, Goblin',
      items: [
        { type: 'weapon', name: 'Greatsword', damage: '2d6', damageType: 'Slashing', toHit: '+5' },
        { type: 'armor', name: 'Plate Armor', ac: 18, armorType: 'Heavy' },
        { type: 'loot', name: '2d10 gp', quantity: '2d10', unit: 'gp' },
        { type: 'loot', name: 'Captain\'s Insignia' },
      ],
      traits: [
        { id: 'martial_advantage_captain', name: 'Martial Advantage', description: 'Once per turn, if the hobgoblin hits a creature with a weapon attack and that creature is within 5 feet of an ally of the hobgoblin that isn\'t incapacitated, the hobgoblin can deal an extra 2d6 damage to the creature.', actionType: 'passive' },
        { id: 'leadership', name: 'Leadership', description: 'As a bonus action, the hobgoblin can utter a special command or warning. Each ally within 30 feet of the hobgoblin that can hear it gains advantage on attack rolls until the start of the hobgoblin\'s next turn.', actionType: 'bonusAction' },
      ]
    },
    { id: 'ghoul', name: 'Ghoul', species: 'Undead', size: 'Medium', hp: 22, ac: 12, cr: '1', xp: 200, hpDice: '5d8', initiativeBonus: 2, movement: '30ft', actions: [{name: 'Claws', dice: '2d6+2', damageType: 'Slashing', toHitModifier: 4}, {name: 'Bite', dice: '2d6+2', damageType: 'Piercing', toHitModifier: 2}], str: 13, dex: 15, con: 10, int: 10, wis: 10, cha: 8,
      proficiencyBonus: 2, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Common, Undercommon',
      items: [
        { type: 'loot', name: 'Ghoul Hand' },
      ],
      traits: [
        { id: 'paralysis', name: 'Paralysis', description: 'If the target is a creature other than an elf or undead, it must succeed on a DC 10 Constitution saving throw or be paralyzed for 1 minute. The target can repeat the saving throw at the end of each of its turns, ending the effect on itself on a success.', actionType: 'passive' },
      ]
    },
    { id: 'fire_elemental', name: 'Fire Elemental', species: 'Elemental', size: 'Large', hp: 102, ac: 13, cr: '5', xp: 1800, hpDice: '12d10+36', initiativeBonus: 4, movement: '50ft', actions: [{name: 'Touch', dice: '2d8+4', damageType: 'Fire', toHitModifier: 6}, {name: 'Fire Form'}], str: 10, dex: 19, con: 13, int: 6, wis: 10, cha: 7,
      proficiencyBonus: 3, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Ignan',
      items: [
        { type: 'loot', name: 'Elemental Core (Fire)', value: '100 gp' },
      ],
      traits: [
        { id: 'fire_form', name: 'Fire Form', description: 'The elemental can move through a space as narrow as 1 inch wide without squeezing. Any creature that touches the elemental or hits it with a melee attack while within 5 feet of it takes 1d10 fire damage. In addition, the elemental can enter a hostile creature\'s space and stop there. The first time it enters a creature\'s space in a turn, that creature takes 1d10 fire damage and catches fire; until someone takes an action to douse the fire, the creature takes 1d10 fire damage at the start of each of its turns.', actionType: 'passive' },
        { id: 'illumination', name: 'Illumination', description: 'The elemental sheds bright light in a 30-foot radius and dim light for an additional 30 feet.', actionType: 'passive' },
        { id: 'water_susceptibility', name: 'Water Susceptibility', description: 'For every 5 feet the elemental moves in water, or for every gallon of water splashed on it, it takes 1 cold damage.', actionType: 'passive' },
      ]
    },
    { id: 'water_elemental', name: 'Water Elemental', species: 'Elemental', size: 'Large', hp: 114, ac: 13, cr: '5', xp: 1800, hpDice: '12d10+48', initiativeBonus: 2, movement: '30ft, Swim 90ft', actions: [{name: 'Slam', dice: '2d8+4', damageType: 'Bludgeoning', toHitModifier: 7}, {name: 'Whelm'}], str: 18, dex: 14, con: 18, int: 5, wis: 10, cha: 8,
      proficiencyBonus: 3, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Aquan',
      items: [
        { type: 'loot', name: 'Elemental Core (Water)', value: '100 gp' },
      ],
      traits: [
        { id: 'water_form', name: 'Water Form', description: 'The elemental can move through a space as narrow as 1 inch wide without squeezing. It can enter a hostile creature\'s space and stop there. The first time it enters a creature\'s space in a turn, that creature takes 1d8 bludgeoning damage and must succeed on a DC 15 Strength saving throw or be grappled (escape DC 15). Until this grapple ends, the target is restrained and unable to breathe unless it can breathe water.', actionType: 'passive' },
        { id: 'freeze', name: 'Freeze', description: 'If the elemental takes cold damage, it partially freezes; its speed is reduced by 20 feet until the end of its next turn.', actionType: 'passive' },
      ]
    },
    { id: 'air_elemental', name: 'Air Elemental', species: 'Elemental', size: 'Large', hp: 90, ac: 15, cr: '5', xp: 1800, hpDice: '12d8+36', initiativeBonus: 4, movement: '0ft, Fly 90ft (hover)', actions: [{name: 'Slam', dice: '2d8+4', damageType: 'Bludgeoning', toHitModifier: 5}, {name: 'Whirlwind'}], str: 14, dex: 20, con: 14, int: 6, wis: 10, cha: 8,
      proficiencyBonus: 3, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Auran',
      items: [
        { type: 'loot', name: 'Elemental Core (Air)', value: '100 gp' },
      ],
      traits: [
        { id: 'air_form', name: 'Air Form', description: 'The elemental can enter a hostile creature\'s space and stop there. The first time it enters a creature\'s space in a turn, that creature takes 1d8 bludgeoning damage and must succeed on a DC 13 Strength saving throw or be knocked prone. The elemental can move through a space as narrow as 1 inch wide without squeezing.', actionType: 'passive' },
      ]
    },
    { id: 'earth_elemental', name: 'Earth Elemental', species: 'Elemental', size: 'Large', hp: 126, ac: 17, cr: '5', xp: 1800, hpDice: '12d10+60', initiativeBonus: -1, movement: '30ft, Burrow 30ft', actions: [{name: 'Slam', dice: '2d8+5', damageType: 'Bludgeoning', toHitModifier: 8}, {name: 'Earth Glide'}], str: 20, dex: 8, con: 20, int: 5, wis: 10, cha: 5,
      proficiencyBonus: 3, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Terran',
      items: [
        { type: 'loot', name: 'Elemental Core (Earth)', value: '100 gp' },
      ],
      traits: [
        { id: 'earth_glide', name: 'Earth Glide', description: 'The elemental can burrow through nonmagical, unworked earth and stone. While doing so, it doesn\'t disturb the material it moves through.', actionType: 'passive' },
        { id: 'siege_monster', name: 'Siege Monster', description: 'The elemental deals double damage to objects and structures.', actionType: 'passive' },
      ]
    },
    { id: 'grick', name: 'Grick', species: 'Aberration', size: 'Medium', hp: 27, ac: 18, cr: '2', xp: 450, hpDice: '6d8', initiativeBonus: 2, movement: '30ft, Climb 30ft', actions: [{name: 'Tentacles', dice: '2d6+2', damageType: 'Slashing', toHitModifier: 4}, {name: 'Beak', dice: '1d6+2', damageType: 'Piercing', toHitModifier: 4}], str: 14, dex: 16, con: 11, int: 3, wis: 14, cha: 5,
      proficiencyBonus: 2, skills: { Stealth: '+6' }, senses: 'Darkvision 60 ft., Passive Perception 12', languages: '—',
      items: [
        { type: 'loot', name: 'Grick Hide', value: '15 gp' },
      ],
      traits: [
        { id: 'stone_camouflage', name: 'Stone Camouflage', description: 'The grick has advantage on Dexterity (Stealth) checks made to hide in rocky terrain.', actionType: 'passive' },
      ]
    },
    { id: 'gargoyle', name: 'Gargoyle', species: 'Elemental', size: 'Medium', hp: 52, ac: 15, cr: '2', xp: 450, hpDice: '7d8+21', initiativeBonus: 0, movement: '30ft, Fly 60ft', actions: [{name: 'Claws', dice: '1d6+3', damageType: 'Sludgeoning', toHitModifier: 4}, {name: 'Bite', dice: '1d6+3', damageType: 'Piercing', toHitModifier: 4}], str: 15, dex: 11, con: 16, int: 6, wis: 11, cha: 7,
      proficiencyBonus: 2, senses: 'Darkvision 60 ft., Passive Perception 10', languages: 'Terran',
      items: [
        { type: 'loot', name: 'Gargoyle Dust' },
      ],
      traits: [
        { id: 'false_appearance', name: 'False Appearance', description: 'While the gargoyle remains motionless, it is indistinguishable from an inanimate statue.', actionType: 'passive' },
        { id: 'standing_leap', name: 'Standing Leap', description: 'The gargoyle\'s long jump is up to 20 feet and its high jump is up to 10 feet, with or without a running start.', actionType: 'passive' },
      ]
    },
    { id: 'mimic', name: 'Mimic', species: 'Monstrosity', size: 'Medium', hp: 58, ac: 12, cr: '2', xp: 450, hpDice: '9d8+18', initiativeBonus: 1, movement: '15ft', actions: [{name: 'Pseudopod', dice: '1d8+3', damageType: 'Bludgeoning', toHitModifier: 5}, {name: 'Bite', dice: '1d8+3', damageType: 'Acid', toHitModifier: 5}], str: 17, dex: 12, con: 15, int: 5, wis: 13, cha: 8,
      proficiencyBonus: 2, skills: { Stealth: '+5' }, senses: 'Darkvision 60 ft., Passive Perception 11', languages: '—',
      items: [
        { type: 'loot', name: 'Mimic Slime', value: '50 gp' },
      ],
      traits: [
        { id: 'adhesive_false_appearance', name: 'Adhesive (False Appearance)', description: 'The mimic adheres to anything that touches it. A Huge or smaller creature adhered to the mimic is also grappled by it (escape DC 13). Ability checks made to escape this grapple have disadvantage.', actionType: 'passive' },
        { id: 'grappler', name: 'Grappler', description: 'The mimic has advantage on attack rolls against any creature grappled by it.', actionType: 'passive' },
      ]
    },
    { id: 'displacer_beast', name: 'Displacer Beast', species: 'Monstrosity', size: 'Large', hp: 85, ac: 13, cr: '3', xp: 700, hpDice: '10d10+30', initiativeBonus: 2, movement: '40ft', actions: [{name: 'Tentacle', dice: '1d6+4', damageType: 'Bludgeoning', toHitModifier: 6}, {name: 'Displacement'}], str: 18, dex: 15, con: 16, int: 6, wis: 12, cha: 8,
      proficiencyBonus: 2, senses: 'Darkvision 60 ft., Passive Perception 11', languages: '—',
      items: [
        { type: 'loot', name: 'Displacer Beast Tentacle', value: '75 gp' },
      ],
      traits: [
        { id: 'displacement', name: 'Displacement', description: 'The displacer beast projects a magical illusion that makes it appear to be standing in a location different from where it actually is, causing attack rolls against it to have disadvantage. If it is hit by an attack, this property is disrupted until the end of its next turn. This property is also disrupted while the displacer beast is incapacitated or has a speed of 0.', actionType: 'passive' },
        { id: 'avoidance', name: 'Avoidance', description: 'If the displacer beast is subjected to an effect that allows it to make a saving throw to take only half damage, it instead takes no damage if it succeeds on the saving throw, and only half damage if it fails.', actionType: 'passive' },
      ]
    },
    { id: 'basilisk', name: 'Basilisk', species: 'Monstrosity', size: 'Medium', hp: 52, ac: 15, cr: '3', xp: 700, hpDice: '9d8+18', initiativeBonus: -1, movement: '20ft', actions: [{name: 'Bite', dice: '2d6+2', damageType: 'Piercing', toHitModifier: 4}, {name: 'Petrifying Gaze'}], str: 16, dex: 8, con: 15, int: 2, wis: 8, cha: 7,
      proficiencyBonus: 2, senses: 'Darkvision 60 ft., Passive Perception 9', languages: '—',
      items: [
        { type: 'loot', name: 'Basilisk Eye', value: '100 gp' },
      ],
      traits: [
        { id: 'petrifying_gaze', name: 'Petrifying Gaze', description: 'If a creature starts its turn within 30 feet of the basilisk and the two of them can see each other, the basilisk can force the creature to make a DC 12 Constitution saving throw if the basilisk isn\'t incapacitated. On a failed save, the creature magically begins to turn to stone and is restrained. It must repeat the saving throw at the end of its next turn. On a success, the effect ends. On a failure, the creature is petrified until freed by the greater restoration spell or other magic.', actionType: 'passive' },
      ]
    },
    { id: 'medusa', name: 'Medusa', species: 'Monstrosity', size: 'Medium', hp: 127, ac: 15, cr: '6', xp: 2300, hpDice: '17d8+51', initiativeBonus: 2, movement: '30ft', actions: [{name: 'Shortsword', dice: '1d6+2', damageType: 'Piercing', toHitModifier: 5}, {name: 'Snake Hair', dice: '1d4+2', damageType: 'Poison', toHitModifier: 5}, {name: 'Petrifying Gaze'}], str: 10, dex: 15, con: 16, int: 12, wis: 13, cha: 15,
      proficiencyBonus: 3, skills: { Deception: '+6', Insight: '+5', Perception: '+5', Stealth: '+5' }, senses: 'Darkvision 60 ft., Passive Perception 15', languages: 'Common, Elvish',
      items: [
        { type: 'weapon', name: 'Shortsword', damage: '1d6', damageType: 'Piercing', toHit: '+5' },
        { type: 'loot', name: 'Medusa\'s Head (Petrified)', value: '500 gp' },
      ],
      traits: [
        { id: 'petrifying_gaze_medusa', name: 'Petrifying Gaze', description: 'When a creature that can see the medusa\'s eyes starts its turn within 30 feet of the medusa, the medusa can force it to make a DC 14 Constitution saving throw if the medusa isn\'t incapacitated and can see the creature. If the saving throw fails by 5 or more, the creature is instantly petrified. Otherwise, a creature that fails the save begins to turn to stone and is restrained. The restrained creature must repeat the saving throw at the end of its next turn, becoming petrified on a failure or ending the effect on a success. The petrification lasts until the creature is freed by the greater restoration spell or other magic.', actionType: 'passive' },
      ]
    },
    { id: 'beholder', name: 'Beholder', species: 'Aberration', size: 'Large', hp: 180, ac: 18, cr: '13', xp: 10000, hpDice: '19d10+76', initiativeBonus: 2, movement: '0ft, Fly 20ft (hover)', actions: [{name: 'Bite', dice: '2d6+4', damageType: 'Piercing', toHitModifier: 5}, {name: 'Eye Rays'}], str: 10, dex: 14, con: 18, int: 17, wis: 15, cha: 17,
      proficiencyBonus: 5, skills: { Perception: '+10' }, senses: 'Darkvision 120 ft., Passive Perception 20', languages: 'Deep Speech, Undercommon',
      items: [
        { type: 'loot', name: 'Beholder Eye Stalk', value: '1000 gp' },
        { type: 'loot', name: 'Beholder Central Eye', value: '5000 gp' },
      ],
      traits: [
        { id: 'antimagic_cone', name: 'Antimagic Cone', description: 'The beholder\'s central eye creates an area of antimagic, as in the antimagic field spell, in a 150-foot cone. At the start of each of its turns, the beholder decides which way the cone faces and whether the cone is active. The cone extends from the beholder and is ignored by its eye rays.', actionType: 'passive' },
      ]
    },
    { id: 'dragon_shadow', name: 'Shadow Dragon (Young Red)', species: 'Dragon', size: 'Large', hp: 172, ac: 18, cr: '13', xp: 10000, hpDice: '16d10+84', initiativeBonus: 0, movement: '40ft, Fly 80ft', actions: [{name: 'Bite', dice: '2d10+6', damageType: 'Piercing', toHitModifier: 10}, {name: 'Claw', dice: '2d6+6', damageType: 'Slashing', toHitModifier: 10}, {name: 'Shadow Breath', dice: '10d6', damageType: 'Necrotic'}], str: 19, dex: 12, con: 17, int: 14, wis: 11, cha: 17,
      proficiencyBonus: 5, skills: { Perception: '+10', Stealth: '+7' }, senses: 'Blindsight 30 ft., Darkvision 120 ft., Passive Perception 20', languages: 'Common, Draconic',
      items: [
        { type: 'loot', name: 'Shadow Dragon Scale', value: '250 gp' },
        { type: 'loot', name: 'Shadow Gem', value: '100 gp' },
      ],
      traits: [
        { id: 'shadow_stealth', name: 'Shadow Stealth', description: 'While in dim light or darkness, the dragon can take the Hide action as a bonus action.', actionType: 'bonusAction' },
      ]
    },
    { id: 'vampire', name: 'Vampire', species: 'Undead', size: 'Medium', hp: 144, ac: 16, cr: '13', xp: 10000, hpDice: '16d8+72', initiativeBonus: 4, movement: '30ft', actions: [{name: 'Unarmed Strike', dice: '1d8+4', damageType: 'Bludgeoning', toHitModifier: 9}, {name: 'Bite (Vampire)', dice: '1d6+4', damageType: 'Necrotic', toHitModifier: 9}], str: 18, dex: 18, con: 18, int: 17, wis: 15, cha: 18,
      proficiencyBonus: 5, skills: { Perception: '+9', Stealth: '+9' }, senses: 'Darkvision 120 ft., Passive Perception 19', languages: 'Common, any two languages',
      items: [
        { type: 'loot', name: 'Vampire Dust', value: '500 gp' },
        { type: 'loot', name: 'Fine Clothes', value: '75 gp' },
      ],
      traits: [
        { id: 'misty_escape', name: 'Misty Escape', description: 'When it drops to 0 hit points outside its resting place, the vampire transforms into a cloud of mist instead of falling unconscious, provided that it isn\'t in sunlight or running water. If it can\'t get to its resting place in 2 hours, it is destroyed.', actionType: 'reaction' },
        { id: 'regeneration', name: 'Regeneration', description: 'The vampire regains 20 hit points at the start of its turn if it has at least 1 hit point and isn\'t in sunlight or running water. If the vampire takes radiant damage or damage from holy water, this trait doesn\'t function at the start of the vampire\'s next turn.', actionType: 'passive' },
      ]
    },
    { id: 'lich_king', name: 'Lich King', species: 'Undead', size: 'Medium', hp: 200, ac: 18, cr: '21', xp: 33000, hpDice: '20d8+110', initiativeBonus: 5, movement: '30ft', actions: [{name: 'Chill Touch (Cantrip)', dice: '2d8', damageType: 'Necrotic', toHitModifier: 10}, {name: 'Disrupt Life (Spell)', dice: '10d6', damageType: 'Necrotic'}, {name: 'Counterspell (Reaction)'}], str: 11, dex: 16, con: 16, int: 20, wis: 14, cha: 16,
      proficiencyBonus: 7, skills: { Arcana: '+12', History: '+12', Insight: '+9', Perception: '+9' }, senses: 'Truesight 120 ft., Passive Perception 19', languages: 'Common, Abyssal, Infernal, Draconic, Elvish, Undercommon',
      items: [
        { type: 'loot', name: 'Orb of Undeath', value: '5000 gp' },
        { type: 'loot', name: 'Lich Phylactery', value: 'Priceless' },
      ],
      traits: [
        { id: 'rejuvenation', name: 'Rejuvenation', description: 'If it has a phylactery, a destroyed lich gains a new body in 1d10 days, regaining all its hit points and becoming active again. The new body appears within 5 feet of the phylactery.', actionType: 'passive' },
        { id: 'turn_resistance', name: 'Turn Resistance', description: 'The lich has advantage on saving throws against any effect that turns undead.', actionType: 'passive' },
      ]
    },
    { id: 'storm_giant', name: 'Storm Giant', species: 'Giant', size: 'Huge', hp: 162, ac: 16, cr: '13', xp: 10000, hpDice: '13d12+78', initiativeBonus: 4, movement: '50ft, Swim 50ft', actions: [{name: 'Greatsword', dice: '6d6+7', damageType: 'Slashing', toHitModifier: 14}, {name: 'Rock', dice: '4d10+7', damageType: 'Bludgeoning', toHitModifier: 14}, {name: 'Lightning Strike'}], str: 29, dex: 14, con: 20, int: 16, wis: 18, cha: 18,
      proficiencyBonus: 5, skills: { Athletics: '+14', Perception: '+9' }, senses: 'Passive Perception 19', languages: 'Common, Giant',
      items: [
        { type: 'weapon', name: 'Giant Greatsword', damage: '6d6', damageType: 'Slashing', toHit: '+14' },
        { type: 'loot', name: 'Giant\'s Club' },
        { type: 'loot', name: '1d1000 gp', quantity: '1d1000', unit: 'gp' },
      ],
      traits: [
        { id: 'amphibious', name: 'Amphibious', description: 'The giant can breathe air and water.', actionType: 'passive' },
        { id: 'innate_spellcasting', name: 'Innate Spellcasting', description: 'The giant\'s innate spellcasting ability is Charisma (spell save DC 16). It can innately cast the following spells, requiring no material components: At will: detect magic, levitate 3/day each: control weather, water breathing', actionType: 'passive' },
      ]
    },
  ], []);

  // Calculate the maximum HP from all monsters for the Max HP scroller limit
  const maxHpLimit = useMemo(() => {
    const highestMonsterHp = allMonsters.reduce((max, monster) => Math.max(max, monster.hp), 0);
    return highestMonsterHp + 200; // Highest HP in DM is 676 (Tarrasque) + 200 = 876
  }, [allMonsters]);


  // Function to generate a unique name for a monster
  const generateMonsterName = useCallback((monsterTemplate, existingNamesSet) => {
    const speciesType = monsterTemplate.species.toLowerCase();
    const availableNames = namesData[speciesType]?.first;
    const availableLastNames = namesData[speciesType]?.last;

    if (!availableNames || availableNames.length === 0) {
      return monsterTemplate.name; // Fallback if no names are defined for species
    }

    let newName = '';
    let attempts = 0;
    const maxAttempts = 100; // Prevent infinite loop

    // Handle "X the Y" format for specific large creatures
    const isSpecialNaming = speciesType === 'dragon' || speciesType === 'elemental';

    do {
      let tempName = availableNames[Math.floor(Math.random() * availableNames.length)];
      if (availableLastNames && availableLastNames.length > 0 && !isSpecialNaming) {
        tempName += ' ' + availableLastNames[Math.floor(Math.random() * availableLastNames.length)];
      }

      if (isSpecialNaming) {
        newName = `${tempName} the ${monsterTemplate.name}`;
      } else {
        newName = tempName;
      }
      attempts++;
    } while (existingNamesSet.has(newName) && attempts < maxAttempts);

    if (attempts >= maxAttempts) {
      console.warn(`Could not find a unique name for ${monsterTemplate.name}. Using default or fallback.`);
      return isSpecialNaming ? `${monsterTemplate.name} ${existingNamesSet.size + 1}` : `${monsterTemplate.name} ${existingNamesSet.size + 1}`; // Fallback if unique name generation fails
    }

    return newName;
  }, [namesData]);


  // Sort the monster list based on the selected sort option
  const sortedMonsters = useMemo(() => {
    let sorted = [...allMonsters];
    switch (monsterSortOption) {
      case 'name':
        sorted.sort((a, b) => a.name.localeCompare(b.name));
        break;
      case 'hp':
        sorted.sort((a, b) => a.hp - b.hp);
        break;
      case 'ac':
        sorted.sort((a, b) => a.ac - b.ac);
        break;
      case 'challenge':
        sorted.sort((a, b) => crToNumber(a.cr) - crToNumber(b.cr));
        break;
      default:
        break;
    }
    return sorted;
  }, [allMonsters, monsterSortOption]);

  // Handle selection of a monster from the dropdown (for adding new)
  useEffect(() => {
    if (selectedMonsterId && newCharacterType === 'monster') {
      const monster = allMonsters.find(m => m.id === selectedMonsterId);
      if (monster) {
        setNewCharacterName(monster.name);
        // Parse HP dice for its parts
        const { dicePart: hpDicePart, modifier: hpModifierPart } = parseDiceNotationForParts(monster.hpDice);
        setNewCharacterHpDice(hpDicePart); // Store XdY part
        setNewCharacterHpModifier(hpModifierPart.toString()); // Store modifier part

        // If rolling HP on add batch is off, use the template HP, otherwise set to 1 for initial display
        setNewCharacterHp(rollHpOnAddBatch ? '1' : monster.hp.toString());
        // Set base roll display for monster
        if (!rollHpOnAddBatch) {
            setNewCharacterHpBaseRollDisplay((monster.hp - hpModifierPart).toString());
        } else {
            setNewCharacterHpBaseRollDisplay(''); // Clear if rolling on batch
        }


        setNewCharacterAc(monster.ac.toString()); // Set AC from monster data
        setNewCharacterMovement(monster.movement ? parseInt(monster.movement).toString() : '0'); // Parse movement to number

        // Monster actions are already objects with name and dice
        // We need to map them to a string for the input, but store as objects
        setNewCharacterActions(monster.actions ? monster.actions.map(a => a.name).join(', ') : '');
        
        // Set the monster's initiative bonus for display
        setCurrentMonsterInitiativeBonus(monster.initiativeBonus || 0);

        // Roll initiative for the first instance
        const d20Roll = Math.floor(Math.random() * 20) + 1;
        const totalInit = d20Roll + (monster.initiativeBonus || 0);
        setNewCharacterInitiative(totalInit.toString()); // Store total in newCharacterInitiative
        setMonsterInitiativeMathDisplay(d20Roll.toString()); // Store just the d20 roll for display

        // Set monster stats to their default if randomization is off
        if (!randomizeNewCombatantStats) {
          setNewCharacterStr(monster.str?.toString() || '10');
          setNewCharacterDex(monster.dex?.toString() || '10');
          setNewCharacterCon(monster.con?.toString() || '10');
          setNewCharacterInt(monster.int?.toString() || '10');
          setNewCharacterWis(monster.wis?.toString() || '10');
          setNewCharacterCha(monster.cha?.toString() || '10');
        } else {
          // If randomize is on, clear for now, will be randomized on add
          setNewCharacterStr('');
          setNewCharacterDex('');
          setNewCharacterCon('');
          setNewCharacterInt('');
          setNewCharacterWis('');
          setNewCharacterCha('');
        }
      }
    } else if (newCharacterType === 'player') {
      // Clear monster specific fields if switching to player
      setNewCharacterName('');
      setNewCharacterInitiative(''); // Clear initiative for player
      setMonsterInitiativeMathDisplay(''); // Clear math display
      setNewCharacterHp('1'); // Reset to default for player
      setNewCharacterAc('0'); // Reset to default for player
      setNewCharacterHpDice(''); // Clear HP dice part
      setNewCharacterHpModifier(''); // Clear HP modifier part
      setNewCharacterHpBaseRollDisplay(''); // Clear for player
      setNewCharacterMovement('0');
      setNewCharacterActions('');
      setCurrentMonsterInitiativeBonus(0); // Clear bonus
      // Clear player stats when switching to player type
      setNewCharacterStr('');
      setNewCharacterDex('');
      setNewCharacterCon('');
      setNewCharacterInt('');
      setNewCharacterWis('');
      setNewCharacterCha('');
    }
  }, [selectedMonsterId, newCharacterType, allMonsters, rollHpOnAddBatch, randomizeNewCombatantStats]); // Added randomizeNewCombatantStats to dependencies


  // Function to roll initiative for monsters
  const handleRollMonsterInitiative = () => {
    const d20Roll = Math.floor(Math.random() * 20) + 1;
    const totalInit = d20Roll + currentMonsterInitiativeBonus;
    setNewCharacterInitiative(totalInit.toString()); // Store total
    setMonsterInitiativeMathDisplay(d20Roll.toString()); // Store just the d20 roll
  };

  // Function to randomize player stats
  const handleRandomizeStats = () => {
    const getRandomStat = () => Math.floor(Math.random() * (15 - 8 + 1)) + 8; // Random between 8 and 15
    setNewCharacterStr(getRandomStat().toString());
    setNewCharacterDex(getRandomStat().toString());
    setNewCharacterCon(getRandomStat().toString());
    setNewCharacterInt(getRandomStat().toString());
    setNewCharacterWis(getRandomStat().toString());
    setNewCharacterCha(getRandomStat().toString());
  };


  // Function to add a new character
  const addCharacter = () => {
    // Helper to get random stats if randomizeNewCombatantStats is true
    const getRandomAbilityScore = () => Math.floor(Math.random() * (15 - 8 + 1)) + 8;

    if (newCharacterType === 'player') {
      if (characters.length >= MAX_TOTAL_COMBATANTS) {
        console.warn(`Cannot add more combatants. Maximum total limit of ${MAX_TOTAL_COMBATANTS} reached.`);
        return;
      }
      if (newCharacterName && newCharacterInitiative !== '' && newCharacterHp !== '') {
        const id = Date.now() + Math.random();

        const finalStr = randomizeNewCombatantStats ? getRandomAbilityScore() : (newCharacterStr !== '' ? parseInt(newCharacterStr) : 10);
        const finalDex = randomizeNewCombatantStats ? getRandomAbilityScore() : (newCharacterDex !== '' ? parseInt(newCharacterDex) : 10);
        const finalCon = randomizeNewCombatantStats ? getRandomAbilityScore() : (newCharacterCon !== '' ? parseInt(newCharacterCon) : 10);
        const finalInt = randomizeNewCombatantStats ? getRandomAbilityScore() : (newCharacterInt !== '' ? parseInt(newCharacterInt) : 10);
        const finalWis = randomizeNewCombatantStats ? getRandomAbilityScore() : (newCharacterWis !== '' ? parseInt(newCharacterWis) : 10);
        const finalCha = randomizeNewCombatantStats ? getRandomAbilityScore() : (newCharacterCha !== '' ? parseInt(newCharacterCha) : 10);

        const newChar = {
          id,
          name: newCharacterName,
          initiative: parseInt(newCharacterInitiative), // For players, it's just the number
          hp: parseInt(newCharacterHp),
          maxHp: parseInt(newCharacterHp),
          ac: newCharacterAc !== '' ? parseInt(newCharacterAc) : undefined,
          baseAc: newCharacterAc !== '' ? parseInt(newCharacterAc) : undefined, // Store base AC
          type: newCharacterType,
          status: 'active',
          movement: newCharacterMovement !== '' ? `${parseInt(newCharacterMovement)}ft` : undefined, // Store movement as "Xft"
          currentMovement: newCharacterMovement !== '' ? parseInt(newCharacterMovement) : undefined, // Initialize currentMovement as number
          // Convert comma-separated actions string to array of objects for players, assigning unique IDs
          actions: newCharacterActions ? newCharacterActions.split(',').map(a => ({name: a.trim(), id: crypto.randomUUID(), isCustom: true})).filter(a => a.name) : [],
          color: COLORS[nextColorIndex], // Assign color sequentially
          actionUsed: false,
          bonusActionUsed: false,
          dashUsed: false,
          reactionUsed: false,
          turnCompleted: false,
          species: 'Human', // Default species for players
          isLocked: false, // New: Default to unlocked
          removedFromCombat: false, // New: Default to not removed from combat
          // Player ability scores
          str: finalStr,
          dex: finalDex,
          con: finalCon,
          int: finalInt,
          wis: finalWis,
          cha: finalCha,
          lastAbilityRoll: null, // Initialize lastAbilityRoll
          items: [], // Players don't have default items from templates
          // NEW: Death Save Properties
          isDying: false,
          deathSuccesses: 0,
          deathFailures: 0,
          deathSaveOpportunities: null, // Null means not in dying state
          hasMadeDeathSaveThisRound: false,
          isCustom: true, // Players are always custom
          traits: [], // Players don't have default traits
          isMovementDashed: false, // New: Track if movement is currently dashed
        };
        setCharacters(prev => {
          const updatedChars = [...prev, newChar];
          console.log("Characters after adding player:", updatedChars); // Debug log
          return updatedChars;
        });
        setNextColorIndex((prevIndex) => (prevIndex + 1) % COLORS.length); // Increment index

        addLogEntry({ type: 'info', characterId: newChar.id, message: `created. Init: ${newChar.initiative}, HP: ${newChar.hp}/${newChar.maxHp}, AC: ${newChar.ac || 'N/A'}, Movement: ${newChar.movement || 'N/A'}` });

        // Clear form fields for single player addition
        setNewCharacterName('');
        setNewCharacterInitiative('');
        setNewCharacterHp('1');
        setNewCharacterAc('0');
        setNewCharacterHpDice('');
        setNewCharacterHpModifier('');
        setNewCharacterHpBaseRollDisplay('');
        setNewCharacterMovement('0');
        setNewCharacterActions('');
        // Clear player stats
        setNewCharacterStr('');
        setNewCharacterDex('');
        setNewCharacterCon('');
        setNewCharacterInt('');
        setNewCharacterWis('');
        setNewCharacterCha('');
        setShowAddForm(false); // Hide form after adding a single player
      } else {
        console.warn('Please fill in all required player details (Name, Initiative, Max HP).');
      }
    } else if (newCharacterType === 'monster') {
      const quantityToAdd = parseInt(newCharacterQuantity) || 1; // Use 1 if input is empty or invalid
      if (selectedMonsterId && quantityToAdd > 0) {
        if (characters.length + quantityToAdd > MAX_TOTAL_COMBATANTS) {
          console.warn(`Cannot add ${quantityToAdd} combatants. Adding them would exceed the maximum total limit of ${MAX_TOTAL_COMBATANTS}. Current: ${characters.length}, Attempted: ${quantityToAdd}`);
          return;
        }
        if (quantityToAdd > MAX_ADD_QUANTITY) {
            console.warn(`Cannot add more than ${MAX_ADD_QUANTITY} monsters at once.`);
            return;
        }

        const monsterTemplate = allMonsters.find(m => m.id === selectedMonsterId);
        if (!monsterTemplate) {
          console.error("Selected monster template not found for ID:", selectedMonsterId);
          return;
        }

        const newMonsters = [];
        // Initiative is already stored as the total in newCharacterInitiative state for monsters
        const initiativeToAssign = parseInt(newCharacterInitiative);
        addLogEntry({ type: 'initiative_set', message: `Initiative for ${monsterTemplate.name}s set to:`, value: initiativeToAssign, details: '(From input field)' });


        const currentBatchUsedNames = new Set();
        const sharedInitiativeId = sharedInitiative ? crypto.randomUUID() : undefined; // Unique ID for this batch if shared

        for (let i = 0; i < quantityToAdd; i++) {
          const id = Date.now() + Math.random(); // Unique ID for each monster
          // Determine HP based on toggle
          const fullHpDiceNotation = `${newCharacterHpDice}${newCharacterHpModifier !== '0' && newCharacterHpModifier !== '' ? (parseInt(newCharacterHpModifier) > 0 ? `+${newCharacterHpModifier}` : newCharacterHpModifier) : ''}`;
          
          let finalHp;
          let rolledHpSumOfDice;

          if (rollHpOnAddBatch && fullHpDiceNotation) {
            const rolledResult = rollDiceDetailed(fullHpDiceNotation);
            finalHp = rolledResult.total;
            rolledHpSumOfDice = rolledResult.sumOfDice;
          } else {
            finalHp = monsterTemplate.hp;
            rolledHpSumOfDice = monsterTemplate.hp - (parseDiceNotationForParts(monsterTemplate.hpDice).modifier || 0);
          }


          const finalInitiative = sharedInitiative ? initiativeToAssign : (Math.floor(Math.random() * 20) + 1 + (currentMonsterInitiativeBonus || 0));

          let finalAc = monsterTemplate.ac;
          if (randomizeAc) {
            const acDeduction = Math.floor(Math.random() * 4); // 0, 1, 2, or 3
            finalAc = Math.max(0, monsterTemplate.ac - acDeduction); // AC cannot go below 0
          }

          let finalActions = [...(monsterTemplate.actions || [])];
          if (randomizeWeapons) {
            if (finalActions.length > 0) {
              // Pick one random action from the existing list and ensure it has a dice property
              const selectedAction = finalActions[Math.floor(Math.random() * finalActions.length)];
              finalActions = [{
                name: selectedAction.name,
                dice: selectedAction.dice || '1d4', // Ensure a default dice if randomized and none exists
                modifier: selectedAction.modifier || 0,
                damageType: selectedAction.damageType || 'Bludgeoning',
                toHitModifier: selectedAction.toHitModifier || 0,
                isCustom: true, // Mark randomized actions as custom
              }];
            } else {
              // If no actions, assign a generic one with some dice
              finalActions = [{name: 'Melee Attack', dice: '1d4', modifier: 0, damageType: 'Bludgeoning', toHitModifier: 0, isCustom: true}];
            }
          }
          // Assign unique IDs to actions within the monster's actions array
          finalActions = finalActions.map(action => ({ ...action, id: crypto.randomUUID() }));


          let finalName = monsterTemplate.name;
          // isCustom for monsters from templates should always be false, even with unique names.
          // The diamond is for truly custom, user-defined entries, not uniquely named template instances.
          const isMonsterCustom = false; // Always false for template-based monsters
          if (createUniqueNames) {
            finalName = generateMonsterName(monsterTemplate, currentBatchUsedNames);
            currentBatchUsedNames.add(finalName); // Add to the set of names used in this batch
          }

          // Determine monster stats based on randomizeNewCombatantStats
          const monsterStr = randomizeNewCombatantStats ? getRandomAbilityScore() : (monsterTemplate.str || 10);
          const monsterDex = randomizeNewCombatantStats ? getRandomAbilityScore() : (monsterTemplate.dex || 10);
          const monsterCon = randomizeNewCombatantStats ? getRandomAbilityScore() : (monsterTemplate.con || 10);
          const monsterInt = randomizeNewCombatantStats ? getRandomAbilityScore() : (monsterTemplate.int || 10);
          const monsterWis = randomizeNewCombatantStats ? getRandomAbilityScore() : (monsterTemplate.wis || 10);
          const monsterCha = randomizeNewCombatantStats ? getRandomAbilityScore() : (monsterTemplate.cha || 10);

          // Ensure items from template do NOT have isCustom: true, unless they are randomized
          const monsterItems = (monsterTemplate.items || []).map(item => ({ ...item, isCustom: randomizeWeapons })); // Mark items as custom if weapons were randomized

          // Copy traits from template, ensuring they have unique IDs and are not marked as custom initially
          const monsterTraits = (monsterTemplate.traits || []).map(trait => ({ ...trait, id: crypto.randomUUID(), isCustom: false }));


          const newMonster = {
            id,
            name: finalName,
            initiative: finalInitiative,
            hp: finalHp,
            maxHp: finalHp, // Max HP is the rolled HP for monsters
            ac: finalAc, // Use potentially randomized AC
            baseAc: monsterTemplate.ac, // Store base AC
            type: 'monster',
            status: 'active',
            movement: monsterTemplate.movement, // Store base movement as string "Xft"
            currentMovement: monsterTemplate.movement ? parseInt(monsterTemplate.movement.replace('ft', '')) : undefined, // Initialize currentMovement as number
            actions: finalActions, // Use potentially randomized actions
            hpDice: monsterTemplate.hpDice, // Keep hpDice for re-rolling in details
            color: COLORS[(nextColorIndex + i) % COLORS.length], // Assign color sequentially
            actionUsed: false,
            bonusActionUsed: false,
            dashUsed: false,
            reactionUsed: false,
            turnCompleted: false,
            species: monsterTemplate.species, // Assign species from template
            isLocked: false, // New: Default to unlocked
            removedFromCombat: false, // New: Default to not removed from combat
            // Monster ability scores
            str: monsterStr,
            dex: monsterDex,
            con: monsterCon,
            int: monsterInt,
            wis: monsterWis,
            cha: monsterCha,
            lastAbilityRoll: null, // Initialize lastAbilityRoll
            items: monsterItems, // Add items from monster template
            cr: monsterTemplate.cr, // Add CR to the character object
            xp: monsterTemplate.xp, // Add XP to the character object
            // NEW: Death Save Properties
            isDying: false,
            deathSuccesses: 0,
            deathFailures: 0,
            deathSaveOpportunities: null, // Null means not in dying state
            hasMadeDeathSaveThisRound: false,
            isCustom: isMonsterCustom, // Set custom flag for monster
            traits: monsterTraits, // Add traits from monster template
            isMovementDashed: false, // New: Track if movement is currently dashed
            size: monsterTemplate.size, // Add size to the character object
            sharedInitiativeId: sharedInitiativeId, // Store the shared initiative ID
            // New monster details
            proficiencyBonus: monsterTemplate.proficiencyBonus,
            skills: monsterTemplate.skills,
            senses: monsterTemplate.senses,
            languages: monsterTemplate.languages,
          };
          newMonsters.push(newMonster);
          addLogEntry({ type: 'info', characterId: newMonster.id, message: `created. Init: ${newMonster.initiative}, HP: ${newMonster.hp}/${newMonster.maxHp}, AC: ${newMonster.ac || 'N/A'}, Movement: ${newMonster.movement || 'N/A'}` });
        }
        setCharacters(prevCharacters => {
          const updatedChars = [...prevCharacters, ...newMonsters];
          console.log("Characters after adding monsters:", updatedChars); // Debug log
          return updatedChars;
        });
        setNextColorIndex((prevIndex) => (prevIndex + quantityToAdd) % COLORS.length);

        // After adding, roll a new initiative for the *next* potential monster addition
        // This ensures the input field is ready for the next monster or batch.
        const d20Roll = Math.floor(Math.random() * 20) + 1;
        const newTotalInit = d20Roll + currentMonsterInitiativeBonus;
        setNewCharacterInitiative(newTotalInit.toString());
        setMonsterInitiativeMathDisplay(d20Roll.toString());

        setNewCharacterQuantity('1'); // Reset quantity to default for NumberScroller
        setShowAddForm(true); // Keep form open for quick multiple additions
      } else {
        console.warn('Please select a monster and specify a quantity greater than 0.');
      }
    }
  };

  // Function to handle rolling HP dice for the new character form
  const handleRollNewCharacterHpDice = () => {
    if (newCharacterHpDice) {
      const fullDiceNotation = `${newCharacterHpDice}${newCharacterHpModifier !== '0' && newCharacterHpModifier !== '' ? (parseInt(newCharacterHpModifier) > 0 ? `+${newCharacterHpModifier}` : newCharacterHpModifier) : ''}`;
      const rolledResult = rollDiceDetailed(fullDiceNotation); // Get detailed result
      setNewCharacterHp(rolledResult.total.toString());
      setNewCharacterHpBaseRollDisplay(rolledResult.sumOfDice.toString()); // Set sum of dice
    }
  };

  // Function to update character HP (used by CharacterCard and CombatantDetails)
  const updateCharacterHp = useCallback((id, newHp) => {
    setCharacters(prevCharacters => prevCharacters.map(char => {
      if (char.id === id) {
        let updatedChar = { ...char, hp: newHp }; // Use newHp directly first

        // If death saves are NOT enabled, and HP drops to 0 or below, instantly kill
        if (!deathSavesEnabled && updatedChar.hp <= 0) {
            updatedChar.isDying = true;
            updatedChar.deathSuccesses = 0;
            updatedChar.deathFailures = 3; // Instant death
            updatedChar.deathSaveOpportunities = 0;
            updatedChar.hasMadeDeathSaveThisRound = false;
            updatedChar.status = 'dead'; // Set status to dead
            addLogEntry({ type: 'info', characterId: updatedChar.id, message: `dropped to 0 HP and dies instantly (Death Saves disabled).` });
            updatedChar.lastAbilityRoll = null; // Clear ability roll if dead
            updatedChar.turnCompleted = true; // Mark turn completed if dead
            return updatedChar; // Return early
        }

        // Ensure HP doesn't go extremely negative (e.g., for instant death calculation)
        // Cap at a reasonable negative (e.g., -maxHp) if instant death rules are strict
        updatedChar.hp = Math.max(updatedChar.hp, -updatedChar.maxHp); // Prevents HP from going absurdly low

        // Logic for entering/exiting dying state (only if death saves are enabled)
        if (deathSavesEnabled) {
            if (updatedChar.hp <= 0 && !updatedChar.isDying) {
                // Just dropped to 0 HP, initiate dying state
                updatedChar.isDying = true;
                updatedChar.deathSuccesses = 0;
                updatedChar.deathFailures = 0;
                updatedChar.deathSaveOpportunities = 4; // Start with 4 opportunities
                updatedChar.hasMadeDeathSaveThisRound = false;
                updatedChar.status = 'unconscious'; // Automatically set status to unconscious
                updatedChar.turnCompleted = true; // Mark turn completed if unconscious/dying
                addLogEntry({ type: 'info', characterId: updatedChar.id, message: `dropped to 0 HP and is now unconscious/dying.` });
            } else if (updatedChar.hp > 0 && updatedChar.isDying) {
                // Healed above 0 HP, no longer dying
                updatedChar.isDying = false;
                updatedChar.deathSuccesses = 0;
                updatedChar.deathFailures = 0;
                updatedChar.deathSaveOpportunities = null;
                updatedChar.hasMadeDeathSaveThisRound = false;
                updatedChar.status = 'active'; // Set status back to active
                updatedChar.turnCompleted = false; // Reset turn completed
                addLogEntry({ type: 'info', characterId: updatedChar.id, message: `is no longer dying and is now active.` });
            }
        }

        // Handle healing from unconscious state (if not from dying)
        if (updatedChar.hp > 0 && updatedChar.status === 'unconscious' && !updatedChar.isDying) {
            updatedChar.status = 'active';
            updatedChar.turnCompleted = false; // Reset turn completed
            addLogEntry({ type: 'info', characterId: updatedChar.id, message: `is no longer unconscious and is now active.` });
        }

        // Check for instant death (massive damage): If damage reduces you to 0 HP and there's remaining damage equal to or exceeding your max HP, you die instantly.
        if (updatedChar.isDying && updatedChar.hp <= -updatedChar.maxHp) {
            updatedChar.deathFailures = 3; // Treat as 3 failures for immediate "red skull" death
            updatedChar.deathSaveOpportunities = 0; // No more opportunities
            updatedChar.status = 'dead'; // Set status to dead
            updatedChar.turnCompleted = true; // Mark turn completed if dead
            addLogEntry({ type: 'info', characterId: updatedChar.id, message: `suffered instant death!` });
        }

        // If status becomes dead, clear the last ability roll
        if (updatedChar.status === 'dead') {
          updatedChar.lastAbilityRoll = null;
        }
        return updatedChar;
      }
      return char;
    }));
  }, [addLogEntry, deathSavesEnabled]);

  // Function to update character status (active, unconscious, dead)
  const updateCharacterStatus = useCallback((id, newStatus) => {
    setCharacters(prevCharacters => prevCharacters.map(char => {
      if (char.id === id) {
        const updatedChar = { ...char, status: newStatus };

        // If manually setting to dead, apply death save failures
        if (newStatus === 'dead') {
          updatedChar.isDying = true; // Ensure dying state is true for skull display
          updatedChar.deathFailures = 3;
          updatedChar.deathSaveOpportunities = 0;
          updatedChar.lastAbilityRoll = null; // Clear ability roll if dead
          updatedChar.turnCompleted = true; // Mark turn completed if dead
        } else if (newStatus === 'unconscious' && updatedChar.hp > 0) {
          // If setting to unconscious manually but HP is above 0, ensure it's not in death save state
          updatedChar.isDying = false;
          updatedChar.deathSuccesses = 0;
          updatedChar.deathFailures = 0;
          updatedChar.deathSaveOpportunities = null;
          updatedChar.hasMadeDeathSaveThisRound = false;
          updatedChar.turnCompleted = true; // Mark turn completed if unconscious
        } else if (newStatus === 'active' && updatedChar.hp <= 0) {
          // Prevent setting to active if HP is 0 or less
          console.warn("Cannot set status to 'active' if HP is 0 or less.");
          return char; // Return original character if invalid state
        } else if (newStatus === 'active' && updatedChar.hp > 0) {
          // If setting to active and HP is positive, ensure not dying
          updatedChar.isDying = false;
          updatedChar.deathSuccesses = 0;
          updatedChar.deathFailures = 0;
          updatedChar.deathSaveOpportunities = null;
          updatedChar.hasMadeDeathSaveThisRound = false;
          updatedChar.turnCompleted = false; // Reset turn completed
        }


        // Apply movement modifiers based on new status
        const statusEffect = STATUS_EFFECTS[newStatus];
        if (statusEffect) {
          if (statusEffect.movement !== undefined) {
            updatedChar.currentMovement = statusEffect.movement;
          } else if (statusEffect.movementMultiplier !== undefined) {
            const baseMovementValue = char.movement ? parseInt(char.movement.replace('ft', '')) : 0;
            updatedChar.currentMovement = Math.floor(baseMovementValue * statusEffect.movementMultiplier);
          } else {
            // If no specific movement modifier, reset to base movement
            updatedChar.currentMovement = char.movement ? parseInt(char.movement.replace('ft', '')) : 0;
          }
        }
        return updatedChar;
      }
      return char;
    }));
  }, []);

  // New function to toggle removedFromCombat status
  const toggleRemovedFromCombat = useCallback((id, isRemoved) => {
    setCharacters(prevCharacters => prevCharacters.map(char => {
      if (char.id === id) {
        const updatedChar = { ...char, removedFromCombat: isRemoved };
        // When removed from combat, also mark actions as used and turn completed
        if (isRemoved) {
          updatedChar.actionUsed = true;
          updatedChar.bonusActionUsed = true;
          updatedChar.dashUsed = true;
          updatedChar.reactionUsed = true;
          updatedChar.turnCompleted = true;
        } else {
          // If restored to combat, reset turn completed
          updatedChar.turnCompleted = false;
        }
        addLogEntry({ type: 'info', characterId: char.id, message: isRemoved ? `removed from combat.` : `restored to combat.` });
        return updatedChar;
      }
      return char;
    }));
    // If a character is removed from combat, close their detail panel
    if (isRemoved) {
      setOpenCombatantIds(prevOpenIds => {
        const newOpenIds = new Set(prevOpenIds);
        newOpenIds.delete(id);
        return newOpenIds;
      });
    }
  }, [addLogEntry]);


  // Function to update character color
  const updateCharacterColor = useCallback((id, newColor) => {
    setCharacters(prevCharacters =>
      prevCharacters.map(char =>
        char.id === id ? { ...char, color: newColor } : char
      )
    );
  }, []); // Dependency array for useCallback

  // Handle selecting/deselecting a combatant - now respects isLocked property
  const handleSelectCombatant = useCallback((id) => {
    setOpenCombatantIds(prevOpenIds => {
      const newOpenIds = new Set(prevOpenIds);
      const clickedCharacter = characters.find(char => char.id === id);

      if (!clickedCharacter) return newOpenIds; // Should not happen

      if (newOpenIds.has(id)) {
        // If already open, close it (toggle off)
        newOpenIds.delete(id);
      } else {
        // If not open, and not locked, close all other UNLOCKED panels
        if (!clickedCharacter.isLocked) {
          prevOpenIds.forEach(openId => {
            const openChar = characters.find(char => char.id === openId);
            if (openChar && !openChar.isLocked) {
              newOpenIds.delete(openId);
            }
          });
        }
        // Then open the clicked one
        newOpenIds.add(id);
      }
      return newOpenIds;
    });
  }, [characters]); // Dependency on characters to find the clicked character's lock state

  // Function to toggle the 'isLocked' status of a character's detail panel
  const onTogglePanelLock = useCallback((id, isLocked) => {
    setCharacters(prevCharacters =>
      prevCharacters.map(char =>
        char.id === id ? { ...char, isLocked: isLocked } : char
      )
    );
    // If a panel is unlocked, ensure it closes if another unlocked panel is opened.
    // This logic is already handled in handleSelectCombatant, but we need to ensure
    // that if a panel is *unlocked*, it behaves like an unlocked panel when a new one is selected.
    // No explicit action needed here, as handleSelectCombatant will re-evaluate based on the new `isLocked` state.
  }, []);


  // Function to update action tracking checkboxes, including mutual exclusivity and Dash movement effect
  const updateActionCheckbox = useCallback((id, checkboxType, value) => {
    setCharacters(prevCharacters =>
      prevCharacters.map(char => {
        if (char.id === id) {
          const newChar = { ...char, [checkboxType]: value };

          // Mutual exclusivity for Action and Dash
          if (checkboxType === 'actionUsed' && value === true) {
            newChar.dashUsed = false;
          } else if (checkboxType === 'dashUsed' && value === true) {
            newChar.actionUsed = false;
          }

          // Dash movement effect
          if (checkboxType === 'dashUsed') {
            const baseMovementValue = char.movement ? parseInt(char.movement.replace('ft', '')) : 0;
            if (value === true) {
              newChar.currentMovement = baseMovementValue * 2;
              newChar.isMovementDashed = true;
              addLogEntry({ type: 'movement_change', characterId: char.id, message: `used Dash, movement doubled to:`, value: newChar.currentMovement, details: `(${baseMovementValue}ft x 2)` });
            } else {
              newChar.currentMovement = baseMovementValue;
              newChar.isMovementDashed = false;
              addLogEntry({ type: 'movement_change', characterId: char.id, message: `Dash ended, movement reset to:`, value: newChar.currentMovement, details: `(${baseMovementValue}ft)` });
            }
          }

          return newChar;
        }
        return char;
      })
    );
  }, [addLogEntry]);

  // Function to update character's actions array (for custom weapons)
  const updateCharacterActions = useCallback((id, newActions) => {
    setCharacters(prevCharacters =>
      prevCharacters.map(char =>
        char.id === id ? { ...char, actions: newActions } : char
      )
    );
  }, []);

  // Function to update character's name
  const updateCharacterName = useCallback((id, newName) => {
    setCharacters(prevCharacters =>
      prevCharacters.map(char =>
        char.id === id ? { ...char, name: newName, isCustom: true } : char // Mark as custom when name is manually changed
      )
    );
  }, []);

  // New: Function to update a character's lastAbilityRoll
  const updateAbilityRoll = useCallback((id, rollData) => {
    setCharacters(prevCharacters =>
      prevCharacters.map(char =>
        char.id === id ? { ...char, lastAbilityRoll: rollData } : char
      )
    );
  }, []);


  // Function to update current movement
  const updateCurrentMovement = useCallback((id, newMovement) => {
    setCharacters(prevCharacters =>
      prevCharacters.map(char => {
        if (char.id === id) {
          // Ensure movement doesn't go below 0
          const updatedMovement = Math.max(0, newMovement);
          return { ...char, currentMovement: updatedMovement };
        }
        return char;
      })
    );
  }, []);

  // NEW: Handle rolling a death saving throw
  const handleRollDeathSave = useCallback((id) => {
    setCharacters(prevCharacters => {
        return prevCharacters.map(combatant => {
            // Only allow rolling if dying and hasn't rolled this round and death saves are enabled
            if (combatant.id === id && combatant.isDying && !combatant.hasMadeDeathSaveThisRound && deathSavesEnabled) {
                const roll = Math.floor(Math.random() * 20) + 1;
                let updatedCombatant = { ...combatant, hasMadeDeathSaveThisRound: true };

                // Decrement opportunity count when a roll is made
                if (updatedCombatant.deathSaveOpportunities !== null && updatedCombatant.deathSaveOpportunities > 0) {
                     updatedCombatant.deathSaveOpportunities--;
                }

                if (roll >= 10) {
                    // Success
                    updatedCombatant.deathSuccesses++;
                    addLogEntry({ type: 'death_save', characterId: combatant.id, message: `rolled a death save:`, value: roll, details: `Success! (${updatedCombatant.deathSuccesses} successes)` });

                    if (updatedCombatant.deathSuccesses >= 3) {
                        // Stabilized and back to 1 HP
                        updatedCombatant.hp = 1;
                        updatedCombatant.isDying = false;
                        updatedCombatant.deathSuccesses = 0;
                        updatedCombatant.deathFailures = 0;
                        updatedCombatant.deathSaveOpportunities = null;
                        updatedCombatant.hasMadeDeathSaveThisRound = false; // Reset for next potential dying state
                        updatedCombatant.status = 'active'; // Set status back to active
                        updatedCombatant.turnCompleted = false; // Reset turn completed
                        addLogEntry({ type: 'info', characterId: combatant.id, message: `is stable and conscious at 1 HP!` });
                    }
                } else {
                    // Failure
                    updatedCombatant.deathFailures++;
                    // Critical failure (1) counts as two failures
                    if (roll === 1) {
                        updatedCombatant.deathFailures++;
                        addLogEntry({ type: 'death_save', characterId: combatant.id, message: `rolled a death save:`, value: roll, details: `Critical Failure! (${updatedCombatant.deathFailures} failures)` });
                    } else {
                        addLogEntry({ type: 'death_save', characterId: combatant.id, message: `rolled a death save:`, value: roll, details: `Failure! (${updatedCombatant.deathFailures} failures)` });
                    }

                    if (updatedCombatant.deathFailures >= 3) {
                        // Character dies from 3 failures
                        updatedCombatant.status = 'dead'; // Set status to dead
                        updatedCombatant.deathSaveOpportunities = 0; // No more opportunities
                        updatedCombatant.turnCompleted = true; // Mark turn completed if dead
                        addLogEntry({ type: 'info', characterId: combatant.id, message: `suffered 3 death saving throw failures and dies!` });
                    }
                }
                return updatedCombatant;
            }
            return combatant;
        });
    });
  }, [addLogEntry, deathSavesEnabled]);

  // NEW: Function to activate a trait (mark action used)
  const handleActivateTrait = useCallback((characterId, trait, actionType) => {
    if (actionType && (actionType === 'action' || actionType === 'bonusAction' || actionType === 'reaction')) {
      updateActionCheckbox(characterId, `${actionType}Used`, true);
      addLogEntry({ type: 'trait_activation', characterId: characterId, message: `activated trait:`, value: trait.name, details: `(${actionType.replace('Action', ' Action')})` });
    } else {
      addLogEntry({ type: 'trait_activation', characterId: characterId, message: `activated trait:`, value: trait.name, details: `(Free Action/Passive)` });
    }
  }, [updateActionCheckbox, addLogEntry]);


  // Function to handle "Next Round" button click
  const handleNextRound = useCallback(() => {
    setRound(prevRound => prevRound + 1); // Increment round counter

    setCharacters(prevCharacters =>
      prevCharacters.map(char => {
        let updatedChar = {
          ...char,
          actionUsed: false,
          bonusActionUsed: false,
          dashUsed: false,
          reactionUsed: false,
          hasMadeDeathSaveThisRound: false, // Reset for new round
          isMovementDashed: false, // Reset dashed movement flag
        };

        // Logic for dying combatants at the start of a new round (only if death saves are enabled)
        if (deathSavesEnabled) {
            if (updatedChar.isDying) {
                // If they were dying and didn't make a save this past round, decrement opportunities
                // Only decrement if deathSaveOpportunities is not null and greater than 0
                if (updatedChar.deathSaveOpportunities !== null && updatedChar.deathSaveOpportunities > 0 && char.hasMadeDeathSaveThisRound === false) {
                    updatedChar.deathSaveOpportunities--;
                    addLogEntry({ type: 'info', characterId: updatedChar.id, message: `missed a death save opportunity. Opportunities left: ${updatedChar.deathSaveOpportunities}` });
                }

                // If they are still dying (not yet dead from failures) and have no opportunities left, they die.
                if (updatedChar.isDying && updatedChar.deathSaveOpportunities !== null && updatedChar.deathSaveOpportunities <= 0 && updatedChar.deathFailures < 3) {
                    updatedChar.deathFailures = 3; // Treat as 3 failures for red skull display
                    updatedChar.status = 'dead'; // Set status to dead
                    addLogEntry({ type: 'info', characterId: updatedChar.id, message: `ran out of death save opportunities and dies!` });
                }

                // If still dying, automatically check turn completed checkbox for the new round
                if (updatedChar.isDying && updatedChar.status !== 'dead') {
                    updatedChar.turnCompleted = true;
                } else {
                    // If they are no longer dying (stabilized or dead), then their turn is not auto-completed
                    updatedChar.turnCompleted = false;
                }
            } else {
                // If not dying, reset turn completed
                updatedChar.turnCompleted = false;
            }
        } else {
            // If death saves are disabled, always reset turn completed
            updatedChar.turnCompleted = false;
        }


        // Apply movement effects based on current status for the new turn
        const statusEffect = STATUS_EFFECTS[updatedChar.status]; // Use updatedChar.status
        if (statusEffect) {
          if (statusEffect.movement !== undefined) {
            updatedChar.currentMovement = statusEffect.movement;
          } else if (statusEffect.movementMultiplier !== undefined) {
            const baseMovementValue = char.movement ? parseInt(char.movement.replace('ft', '')) : 0;
            updatedChar.currentMovement = Math.floor(baseMovementValue * statusEffect.movementMultiplier);
          } else {
            // If no specific movement modifier, reset to base movement
            updatedChar.currentMovement = char.movement ? parseInt(char.movement.replace('ft', '')) : undefined;
          }
        } else {
          // If status is not found or is 'active', reset to base movement
          updatedChar.currentMovement = char.movement ? parseInt(char.movement.replace('ft', '')) : undefined;
        }
        return updatedChar;
      })
    );
    addLogEntry({ type: 'info', message: `Round ${round} ended. Round ${round + 1} initiated! All actions reset, movement restored.` });
    console.log(`Round ${round} ended. Round ${round + 1} initiated! All actions reset, movement restored.`);

    // Reset current initiative index to 0 for the new round, to start from the top of the new sorted list
    setCurrentInitiativeIndex(0);

  }, [round, addLogEntry, deathSavesEnabled]);


  // Function to reroll initiatives for all combatants
  const handleRerollAllInitiatives = useCallback(() => {
    setCharacters(prevCharacters => {
      const updatedCharacters = [...prevCharacters];
      const sharedInitiativeRolls = new Map(); // Map to store one roll per sharedInitiativeId

      updatedCharacters.forEach(char => {
        // Skip if removed from combat or dead
        if (char.removedFromCombat || char.status === 'dead') {
          return;
        }

        let initiativeModifier = 0;
        if (char.type === 'player') {
          initiativeModifier = Math.floor(((char.dex || 10) - 10) / 2);
        } else if (char.type === 'monster') {
          const monsterTemplate = allMonsters.find(m => m.id === char.id);
          initiativeModifier = monsterTemplate ? (monsterTemplate.initiativeBonus || 0) : 0;
        }

        let newInitiative;
        if (char.sharedInitiativeId) {
          // If this combatant belongs to a shared initiative group
          if (!sharedInitiativeRolls.has(char.sharedInitiativeId)) {
            // If this group hasn't rolled yet, roll for the group
            const d20Roll = Math.floor(Math.random() * 20) + 1;
            newInitiative = d20Roll + initiativeModifier;
            sharedInitiativeRolls.set(char.sharedInitiativeId, newInitiative);
            addLogEntry({ type: 'initiative_roll', characterId: char.id, message: `(Group) rerolled initiative:`, value: newInitiative, details: `(${d20Roll} + ${initiativeModifier})` });
          } else {
            // If group already rolled, use that roll
            newInitiative = sharedInitiativeRolls.get(char.sharedInitiativeId);
          }
        } else {
          // Individual combatant (player or individually added monster)
          const d20Roll = Math.floor(Math.random() * 20) + 1;
          newInitiative = d20Roll + initiativeModifier;
          addLogEntry({ type: 'initiative_roll', characterId: char.id, message: `rerolled initiative:`, value: newInitiative, details: `(${d20Roll} + ${initiativeModifier})` });
        }
        char.initiative = newInitiative; // Update the character's initiative
      });
      return updatedCharacters;
    });
    addLogEntry({ type: 'info', message: `All active combatants' initiatives rerolled.` });
  }, [addLogEntry, allMonsters]);


  // Sort characters by initiative (descending) for the initiative order list
  const sortedCharactersForInitiative = useMemo(() => {
    const activeCharacters = [];
    const removedOrDeadCharacters = [];

    characters.forEach(char => {
      // Check for red skull condition (dead or 3+ failures/0 opportunities)
      const isRedSkull = char.isDying && (char.deathFailures >= 3 || (char.deathSaveOpportunities !== null && char.deathSaveOpportunities <= 0));

      if (isRedSkull || char.removedFromCombat) { // Include removedFromCombat in this group
        removedOrDeadCharacters.push(char);
      } else {
        activeCharacters.push(char);
      }
    });

    // Sort active characters by initiative (descending)
    activeCharacters.sort((a, b) => b.initiative - a.initiative);

    // Sort removed/dead characters by initiative (descending) but keep them at the bottom
    removedOrDeadCharacters.sort((a, b) => b.initiative - a.initiative);

    return [...activeCharacters, ...removedOrDeadCharacters];
  }, [characters]);


  // Sort characters by name for the summary list (or any other desired default sort for this list)
  const sortedCharactersForSummary = useMemo(() => {
    // This list will be manually reordered by drag and drop,
    // so we return the characters array directly to allow state updates to control order.
    // However, for initial display, we might want a default sort.
    // For now, it will reflect the order in the `characters` state.
    return [...characters]; // Return a copy to avoid direct mutation issues
  }, [characters]);


  // Drag and Drop Handlers for "All Combatants Overview"
  const handleDragStart = useCallback((e, id) => {
    setDraggedItemId(id);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', id); // Required for Firefox
  }, []);

  const handleDragOver = useCallback((e, id) => {
    e.preventDefault(); // Necessary to allow dropping
    setDragOverItemId(id);
  }, []);

  const handleDragLeave = useCallback(() => {
    setDragOverItemId(null);
  }, []);

  const handleDrop = useCallback((e, targetId) => {
    e.preventDefault();
    setDragOverItemId(null);

    if (draggedItemId === null || draggedItemId === targetId) {
      return;
    }

    setCharacters(prevCharacters => {
      const newCharacters = [...prevCharacters];
      const draggedIndex = newCharacters.findIndex(char => char.id === draggedItemId);
      const targetIndex = newCharacters.findIndex(char => char.id === targetId);

      if (draggedIndex === -1 || targetIndex === -1) {
        return prevCharacters;
      }

      const [draggedItem] = newCharacters.splice(draggedIndex, 1);
      newCharacters.splice(targetIndex, 0, draggedItem);
      return newCharacters;
    });
    setDraggedItemId(null);
  }, [draggedItemId]);

  // New: Function to remove a combatant and move their items to loot
  const handleRemoveAndLoot = useCallback((id) => {
    setCharacters(prevCharacters => {
      const characterToRemove = prevCharacters.find(char => char.id === id);
      if (characterToRemove) {
        // Add to deletedCharacters list with a flag indicating it was "removed and looted"
        setDeletedCharacters(prevDeleted => {
          const newDeleted = [...prevDeleted, { ...characterToRemove, wasLooted: true }];
          if (newDeleted.length > MAX_UNDO_BUFFER) {
            return newDeleted.slice(newDeleted.length - MAX_UNDO_BUFFER);
          }
          return newDeleted;
        });

        // Add XP to total pool
        if (characterToRemove.xp !== undefined) {
          setTotalXpPool(prevXp => prevXp + characterToRemove.xp);
        }

        // Add items to loot pool
        if (characterToRemove.items && characterToRemove.items.length > 0) {
          setLootPool(prevLoot => {
            const updatedLoot = [...prevLoot];
            characterToRemove.items.forEach(item => {
              // Check if item already exists in loot pool to aggregate quantity
              const existingItemIndex = updatedLoot.findIndex(
                lootItem => lootItem.name === item.name && lootItem.unit === item.unit && lootItem.isCustom === item.isCustom
              );

              if (existingItemIndex > -1 && item.quantity) {
                const existingQty = parseInt(updatedLoot[existingItemIndex].quantity) || 0;
                const newItemQty = parseInt(item.quantity) || 0;
                if (!isNaN(existingQty) && !isNaN(newItemQty)) {
                  updatedLoot[existingItemIndex].quantity = (existingQty + newItemQty).toString();
                } else {
                  updatedLoot.push({ ...item, id: crypto.randomUUID() });
                }
              } else {
                updatedLoot.push({ ...item, id: crypto.randomUUID() });
              }
            });
            return updatedLoot;
          });
          addLogEntry({ type: 'loot', message: `Items from ${characterToRemove.name} added to loot pool.` });
        }
        addLogEntry({ type: 'info', characterId: id, message: `removed from combat and items moved to loot.` });
      }
      return prevCharacters.filter(char => char.id !== id);
    });
    setOpenCombatantIds(prevOpenIds => {
      const newOpenIds = new Set(prevOpenIds);
      newOpenIds.delete(id);
      return newOpenIds;
    });
  }, [addLogEntry]);

  // New: Function to delete a combatant without moving items
  const handleDeleteCombatant = useCallback((id) => {
    setCharacters(prevCharacters => {
      const charToDelete = prevCharacters.find(char => char.id === id);
      if (charToDelete) {
        setDeletedCharacters(prevDeleted => {
          const newDeleted = [...prevDeleted, { ...charToDelete, wasLooted: false }]; // Mark as not looted
          if (newDeleted.length > MAX_UNDO_BUFFER) {
            return newDeleted.slice(newDeleted.length - MAX_UNDO_BUFFER); // Keep only the last 20
          }
          return newDeleted;
        });
        addLogEntry({ type: 'info', characterId: id, message: `deleted from combat.` });
      }
      return prevCharacters.filter(char => char.id !== id);
    });
    setOpenCombatantIds(prevOpenIds => {
      const newOpenIds = new Set(prevOpenIds);
      newOpenIds.delete(id);
      return newOpenIds;
    });
  }, [addLogEntry]);

  // New: Function to restore a deleted character
  const handleRestoreDeletedCharacter = useCallback((id) => {
    setDeletedCharacters(prevDeleted => {
      const charToRestore = prevDeleted.find(char => char.id === id);
      if (charToRestore) {
        // If the character was looted, restore XP and items
        if (charToRestore.wasLooted) {
          // Restore XP
          if (charToRestore.xp !== undefined) {
            setTotalXpPool(prevXp => Math.max(0, prevXp - charToRestore.xp)); // Ensure XP doesn't go negative
          }
          // Restore items from loot pool
          if (charToRestore.items && charToRestore.items.length > 0) {
            setLootPool(prevLoot => {
              const updatedLoot = [...prevLoot];
              charToRestore.items.forEach(itemToRestore => {
                const existingItemIndex = updatedLoot.findIndex(
                  lootItem => lootItem.name === itemToRestore.name && lootItem.unit === itemToRestore.unit && lootItem.isCustom === itemToRestore.isCustom
                );

                if (existingItemIndex > -1 && itemToRestore.quantity) {
                  const existingQty = parseInt(updatedLoot[existingItemIndex].quantity) || 0;
                  const restoreQty = parseInt(itemToRestore.quantity) || 0;
                  const newQty = existingQty - restoreQty;
                  if (newQty <= 0) {
                    updatedLoot.splice(existingItemIndex, 1); // Remove if quantity drops to 0 or less
                  } else {
                    updatedLoot[existingItemIndex].quantity = newQty.toString();
                  }
                } else {
                  // If item to restore doesn't have quantity or wasn't found, just remove one instance if it exists
                  const singleItemIndex = updatedLoot.findIndex(
                    lootItem => lootItem.name === itemToRestore.name && lootItem.unit === itemToRestore.unit && lootItem.isCustom === itemToRestore.isCustom
                  );
                  if (singleItemIndex > -1) {
                    updatedLoot.splice(singleItemIndex, 1);
                  }
                }
              });
              return updatedLoot;
            });
            addLogEntry({ type: 'loot_restore', message: `Items from ${charToRestore.name} removed from loot pool.` });
          }
        }

        // Ensure character is not already in active combatants (edge case)
        setCharacters(prevChars => {
          if (!prevChars.some(char => char.id === id)) {
            addLogEntry({ type: 'info', characterId: id, message: `restored from undo list.` });
            return [...prevChars, { ...charToRestore, removedFromCombat: false, status: 'active', turnCompleted: false }]; // Restore as active, not removed
          }
          return prevChars;
        });
        return prevDeleted.filter(char => char.id !== id); // Remove from deleted list
      }
      return prevDeleted;
    });
  }, [addLogEntry]);

  // Group loot items for display
  const groupedLootPool = useMemo(() => {
    const grouped = {};
    lootPool.forEach(item => {
      const key = `${item.name}-${item.unit || ''}-${item.isCustom || false}`; // Group by name, unit, and custom status
      if (!grouped[key]) {
        grouped[key] = { ...item, quantity: 0 }; // Initialize quantity
      }
      const itemQuantity = parseInt(item.quantity) || 1; // Default to 1 if no quantity
      grouped[key].quantity += itemQuantity;
    });
    return Object.values(grouped);
  }, [lootPool]);


  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 to-gray-700 text-white font-inter p-4 sm:p-8">
      <style>
        {`
          @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
          body { font-family: 'Inter', sans-serif; }
        `}
      </style>

      <div className="max-w-7xl mx-auto bg-gray-800 rounded-2xl shadow-2xl p-6 sm:p-8 border border-gray-700 flex flex-col md:flex-row gap-8">
        {/* Left Half: Menu and Summary List */}
        <div className="w-full md:w-1/2 space-y-8">
          <h1 className="text-3xl sm:text-4xl font-extrabold text-center text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">
            Battle Tracker
          </h1>

          {/* Add Combatant Form */}
          <div className="p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600">
            <button
              onClick={() => setShowAddForm(!showAddForm)}
              className="w-full py-3 px-6 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-md transition-all duration-300 flex items-center justify-center space-x-2 transform hover:scale-105"
            >
              {showAddForm ? <Minus className="w-5 h-5" /> : <Plus className="w-5 h-5" />}
              <span>{showAddForm ? 'Hide Add Form' : 'Add New Combatant'}</span>
            </button>

            {showAddForm && (
              <div className="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-4">
                {/* Type selection */}
                <div className="col-span-1 sm:col-span-2">
                  <label htmlFor="combatant-type" className="block text-sm font-medium text-gray-300 mb-1">Combatant Type</label>
                  <select
                    id="combatant-type"
                    value={newCharacterType}
                    onChange={(e) => {
                      setNewCharacterType(e.target.value);
                      setSelectedMonsterId(''); // Clear monster selection when type changes
                    }}
                    className="p-3 rounded-lg bg-gray-600 text-white border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full"
                  >
                    <option value="player">Player</option>
                    <option value="monster">Monster</option>
                  </select>
                </div>

                {newCharacterType === 'monster' ? (
                  <>
                    {/* Monster sorting options (moved above select monster) */}
                    <div className="col-span-1 sm:col-span-2">
                      <label htmlFor="monster-sort" className="block text-sm font-medium text-gray-300 mb-1">Sort Monster List By</label>
                      <select
                        id="monster-sort"
                        value={monsterSortOption}
                        onChange={(e) => setMonsterSortOption(e.target.value)}
                        className="p-3 rounded-lg bg-gray-600 text-white border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full"
                      >
                        <option value="name">Name</option>
                        <option value="hp">HP</option>
                        <option value="ac">AC</option>
                        <option value="challenge">Challenge</option> {/* New sort option */}
                      </select>
                    </div>

                    {/* Monster selection dropdown */}
                    <div className="col-span-1 sm:col-span-2">
                      <label htmlFor="monster-select" className="block text-sm font-medium text-gray-300 mb-1">Select Monster</label>
                      <select
                        id="monster-select"
                        value={selectedMonsterId}
                        onChange={(e) => setSelectedMonsterId(e.target.value)}
                        className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full"
                      >
                        <option value="">-- Select a Monster --</option>
                        {sortedMonsters.map(monster => (
                          <option key={monster.id} value={monster.id}>
                            {monster.name} {monster.cr ? `(CR ${monster.cr})` : ''} (HP: {monster.hp}, AC: {monster.ac}, Size: {monster.size})
                          </option>
                        ))}
                      </select>
                    </div>

                    {/* Row 1: AC and Max HP */}
                    <div className="col-span-1 sm:col-span-2 flex flex-col sm:flex-row sm:space-x-4">
                      {/* AC elements */}
                      <div className="flex-1 mb-4 sm:mb-0">
                        <label htmlFor="monster-ac" className="block text-sm font-medium text-gray-300 mb-1">Armor Class (AC)</label>
                        <NumberScroller
                          value={newCharacterAc}
                          onChange={setNewCharacterAc}
                          min={0}
                          max={40}
                          isDefaultValueDisplay={true}
                          inputWidthClass="w-12"
                          buttonPaddingClass="p-0.5"
                          iconSizeClass="w-3 h-3"
                        />
                      </div>
                      {/* Max HP elements */}
                      <div className="flex-1">
                        <label htmlFor="monster-hp" className="block text-sm font-medium text-gray-300 mb-1">Max HP</label>
                        <div className="flex items-center space-x-1">
                            <NumberScroller
                                value={newCharacterHp}
                                onChange={setNewCharacterHp}
                                min={1}
                                max={maxHpLimit}
                                textColorClass="text-blue-400"
                                inputWidthClass="w-12"
                                buttonPaddingClass="p-0.5"
                                iconSizeClass="w-3 h-3"
                            />
                            <span className="text-gray-300 text-sm">=</span>
                            <div className="p-1 rounded-lg bg-gray-600 text-white border border-gray-500 w-10 text-center text-gray-300 text-xs">
                                {newCharacterHpBaseRollDisplay || '0'}
                            </div>
                            <span className="text-gray-300 text-sm">+</span>
                            <NumberScroller
                                value={newCharacterHpModifier}
                                onChange={setNewCharacterHpModifier}
                                min={-50}
                                max={50}
                                hideControls={true}
                                isDefaultValueDisplay={true}
                                inputWidthClass="w-8"
                                buttonPaddingClass="p-0.5"
                                iconSizeClass="w-3 h-3"
                            />
                            {newCharacterHpDice && (
                                <button
                                  onClick={handleRollNewCharacterHpDice}
                                  className="p-1.5 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition-all duration-300 flex items-center justify-center space-x-1 whitespace-nowrap text-sm"
                                  title="Roll HP Dice"
                                >
                                  <Dice className="w-4 h-4" />
                                  <span>{newCharacterHpDice}</span>
                                </button>
                            )}
                        </div>
                      </div>
                    </div>

                    {/* Row 2: Movement and Initiative */}
                    <div className="col-span-1 sm:col-span-2 flex flex-col sm:flex-row sm:space-x-4">
                      {/* Movement elements */}
                      <div className="flex-1 mb-4 sm:mb-0">
                        <label htmlFor="monster-movement" className="block text-sm font-medium text-gray-300 mb-1">Movement</label>
                        <NumberScroller
                          value={newCharacterMovement}
                          onChange={setNewCharacterMovement}
                          min={0}
                          max={200}
                          step={5}
                          displayUnit="ft"
                          isDefaultValueDisplay={true}
                          inputWidthClass="w-12"
                          buttonPaddingClass="p-0.5"
                          iconSizeClass="w-3 h-3"
                        />
                      </div>
                      {/* Initiative elements */}
                      <div className="flex-1">
                          <label htmlFor="monster-initiative-display" className="block text-sm font-medium text-gray-300 mb-1">Initiative</label>
                          <div className="flex items-center space-x-1">
                              <NumberScroller
                                  value={newCharacterInitiative}
                                  onChange={setNewCharacterInitiative}
                                  min={-10}
                                  max={30}
                                  textColorClass="text-blue-400"
                                  inputWidthClass="w-12"
                                  buttonPaddingClass="p-0.5"
                                  iconSizeClass="w-3 h-3"
                              />
                              <span className="text-gray-300 text-sm">=</span>
                              <div className="p-1 rounded-lg bg-gray-600 text-white border border-gray-500 w-10 text-center text-gray-300 text-xs">
                                  {monsterInitiativeMathDisplay || '0'}
                              </div>
                              <span className="text-gray-300 text-sm">+</span>
                              <NumberScroller
                                  value={currentMonsterInitiativeBonus.toString()}
                                  onChange={setCurrentMonsterInitiativeBonus}
                                  min={-10}
                                  max={10}
                                  hideControls={true}
                                  isDefaultValueDisplay={true}
                                  inputWidthClass="w-8"
                                  buttonPaddingClass="p-0.5"
                                  iconSizeClass="w-3 h-3"
                              />
                              <button
                                onClick={handleRollMonsterInitiative}
                                className="p-1.5 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition-all duration-300 flex items-center justify-center whitespace-nowrap text-sm"
                                title="Roll Monster Initiative"
                              >
                                <Dice className="w-4 h-4 mr-1" />
                                <span>1d20</span>
                              </button>
                          </div>
                      </div>
                    </div>

                    {/* Row 3: Quantity */}
                    <div className="col-span-1 sm:col-span-2">
                        <label htmlFor="monster-quantity" className="block text-sm font-medium text-gray-300 mb-1">Quantity</label>
                        <NumberScroller
                            value={newCharacterQuantity}
                            onChange={setNewCharacterQuantity}
                            min={1}
                            max={MAX_ADD_QUANTITY}
                            isDefaultValueDisplay={true}
                            inputWidthClass="w-12"
                            buttonPaddingClass="p-0.5"
                            iconSizeClass="w-3 h-3"
                        />
                    </div>

                    {/* Actions input for monsters */}
                    <div className="col-span-1 sm:col-span-2">
                      <label htmlFor="monster-actions" className="block text-sm font-medium text-gray-300 mb-1">Actions (comma-separated)</label>
                      <textarea
                        id="monster-actions"
                        placeholder="e.g., Bite, Claw, Fire Breath"
                        value={newCharacterActions}
                        onChange={(e) => setNewCharacterActions(e.target.value)}
                        rows="2"
                        className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full"
                      ></textarea>
                    </div>

                    {/* Randomization Checkboxes for Monsters */}
                    <div className="col-span-1 sm:col-span-2 grid grid-cols-1 sm:grid-cols-3 gap-4 mt-4">
                      <div className="flex items-center">
                        <input
                          id="randomize-ac"
                          type="checkbox"
                          checked={randomizeAc}
                          onChange={(e) => setRandomizeAc(e.target.checked)}
                          className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                        />
                        <label htmlFor="randomize-ac" className="ml-2 block text-sm text-gray-300">Randomize AC (-0 to -3)</label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="randomize-weapons"
                          type="checkbox"
                          checked={randomizeWeapons}
                          onChange={(e) => setRandomizeWeapons(e.target.checked)}
                          className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                        />
                        <label htmlFor="randomize-weapons" className="ml-2 block text-sm text-gray-300">Randomize Actions</label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="create-unique-names"
                          type="checkbox"
                          checked={createUniqueNames}
                          onChange={(e) => setCreateUniqueNames(e.target.checked)}
                          className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                        />
                        <label htmlFor="create-unique-names" className="ml-2 block text-sm text-gray-300">Create Unique Names</label>
                      </div>
                      <div className="flex items-center col-span-1 sm:col-span-3"> {/* Full width for this checkbox */}
                        <input
                          id="shared-initiative"
                          type="checkbox"
                          checked={sharedInitiative}
                          onChange={(e) => setSharedInitiative(e.target.checked)}
                          className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                        />
                        <label htmlFor="shared-initiative" className="ml-2 block text-sm text-gray-300">Shared Initiative (All added monsters get same initiative)</label>
                      </div>
                      <div className="flex items-center col-span-1 sm:col-span-3"> {/* New HP roll toggle */}
                        <input
                          id="roll-hp-on-add-batch"
                          type="checkbox"
                          checked={rollHpOnAddBatch}
                          onChange={(e) => setRollHpOnAddBatch(e.target.checked)}
                          className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                        />
                        <label htmlFor="roll-hp-on-add-batch" className="ml-2 block text-sm text-gray-300">Roll HP for each monster when adding multiple</label>
                      </div>
                      {/* New: Randomize Stats Checkbox (applies to both types) - MOVED HERE */}
                      <div className="col-span-1 sm:col-span-3 flex items-center">
                        <input
                          id="randomize-new-combatant-stats"
                          type="checkbox"
                          checked={randomizeNewCombatantStats}
                          onChange={(e) => {
                            setRandomizeNewCombatantStats(e.target.checked);
                            if (e.target.checked) {
                              // If checked, clear current manual inputs for stats
                              setNewCharacterStr('');
                              setNewCharacterDex('');
                              setNewCharacterCon('');
                              setNewCharacterInt('');
                              setNewCharacterWis('');
                              setNewCharacterCha('');
                            } else {
                              // If unchecked, and it's a monster, restore default monster stats
                              if (newCharacterType === 'monster' && selectedMonsterId) {
                                const monster = allMonsters.find(m => m.id === selectedMonsterId);
                                if (monster) {
                                  setNewCharacterStr(monster.str?.toString() || '10');
                                  setNewCharacterDex(monster.dex?.toString() || '10');
                                  setNewCharacterCon(monster.con?.toString() || '10');
                                  setNewCharacterInt(monster.int?.toString() || '10');
                                  setNewCharacterWis(monster.wis?.toString() || '10');
                                  setNewCharacterCha(monster.cha?.toString() || '10');
                                }
                              }
                            }
                          }}
                          className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                        />
                        <label htmlFor="randomize-new-combatant-stats" className="ml-2 block text-sm text-gray-300">Randomize All 6 Stats (8-15)</label>
                      </div>
                    </div>
                  </>
                ) : (
                  <>
                    {/* Player specific inputs */}
                    <div>
                      <label htmlFor="player-name" className="block text-sm font-medium text-gray-300 mb-1">Player Name</label>
                      <input
                        id="player-name"
                        type="text"
                        placeholder="Player Name"
                        value={newCharacterName}
                        onChange={(e) => setNewCharacterName(e.target.value)}
                        maxLength={30} // Max length for player name
                        className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full"
                      />
                    </div>
                    <div>
                      <label htmlFor="player-initiative" className="block text-sm font-medium text-gray-300 mb-1">Initiative</label>
                      <input
                        id="player-initiative"
                        type="number"
                        placeholder="Initiative"
                        value={newCharacterInitiative}
                        onChange={(e) => setNewCharacterInitiative(e.target.value)}
                        className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full"
                      />
                    </div>
                    <div>
                      <label htmlFor="player-hp" className="block text-sm font-medium text-gray-300 mb-1">Max HP</label>
                      <NumberScroller
                        value={newCharacterHp}
                        onChange={setNewCharacterHp}
                        min={1}
                        max={maxHpLimit}
                      />
                    </div>
                    {/* AC input for players (optional) */}
                    <div>
                      <label htmlFor="player-ac" className="block text-sm font-medium text-gray-300 mb-1">Armor Class (AC) (Optional)</label>
                      <NumberScroller
                        value={newCharacterAc}
                        onChange={setNewCharacterAc}
                        min={0}
                        max={40}
                        isDefaultValueDisplay={true} // Set to true for default display
                      />
                    </div>
                    {/* Movement input for players (optional) */}
                    <div>
                      <label htmlFor="player-movement" className="block text-sm font-medium text-gray-300 mb-1">Movement (Optional)</label>
                      <NumberScroller
                        value={newCharacterMovement}
                        onChange={setNewCharacterMovement}
                        min={0}
                        max={200}
                        step={5}
                        displayUnit="ft"
                        isDefaultValueDisplay={true} // Set to true for default display
                      />
                    </div>
                    {/* Actions input for players (optional) */}
                    <div className="col-span-1 sm:col-span-2">
                      <label htmlFor="player-actions" className="block text-sm font-medium text-gray-300 mb-1">Actions (comma-separated, Optional)</label>
                      <textarea
                        id="player-actions"
                        placeholder="e.g., Bite, Claw, Fire Breath"
                        value={newCharacterActions}
                        onChange={(e) => setNewCharacterActions(e.target.value)}
                        rows="2"
                        className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full"
                      ></textarea>
                    </div>
                    {/* Player Ability Scores */}
                    <div className="col-span-1 sm:col-span-2 grid grid-cols-2 sm:grid-cols-3 gap-4 mt-4">
                      <div>
                        <label htmlFor="player-str" className="block text-sm font-medium text-gray-300 mb-1">STR</label>
                        <input type="number" id="player-str" value={newCharacterStr} onChange={(e) => setNewCharacterStr(e.target.value)} className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full" placeholder="10" disabled={randomizeNewCombatantStats} />
                      </div>
                      <div>
                        <label htmlFor="player-dex" className="block text-sm font-medium text-gray-300 mb-1">DEX</label>
                        <input type="number" id="player-dex" value={newCharacterDex} onChange={(e) => setNewCharacterDex(e.target.value)} className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full" placeholder="10" disabled={randomizeNewCombatantStats} />
                      </div>
                      <div>
                        <label htmlFor="player-con" className="block text-sm font-medium text-gray-300 mb-1">CON</label>
                        <input type="number" id="player-con" value={newCharacterCon} onChange={(e) => setNewCharacterCon(e.target.value)} className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full" placeholder="10" disabled={randomizeNewCombatantStats} />
                      </div>
                      <div>
                        <label htmlFor="player-int" className="block text-sm font-medium text-gray-300 mb-1">INT</label>
                        <input type="number" id="player-int" value={newCharacterInt} onChange={(e) => setNewCharacterInt(e.target.value)} className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full" placeholder="10" disabled={randomizeNewCombatantStats} />
                      </div>
                      <div>
                        <label htmlFor="player-wis" className="block text-sm font-medium text-gray-300 mb-1">WIS</label>
                        <input type="number" id="player-wis" value={newCharacterWis} onChange={(e) => setNewCharacterWis(e.target.value)} className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full" placeholder="10" disabled={randomizeNewCombatantStats} />
                      </div>
                      <div>
                        <label htmlFor="player-cha" className="block text-sm font-medium text-gray-300 mb-1">CHA</label>
                        <input type="number" id="player-cha" value={newCharacterCha} onChange={(e) => setNewCharacterCha(e.target.value)} className="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 w-full" placeholder="10" disabled={randomizeNewCombatantStats} />
                      </div>
                      <button
                        onClick={handleRandomizeStats}
                        className={`col-span-2 sm:col-span-3 py-2 px-4 bg-green-600 text-white font-bold rounded-lg shadow-md transition-all duration-300
                          ${randomizeNewCombatantStats ? 'opacity-50 cursor-not-allowed' : 'hover:bg-green-700'}`}
                        disabled={randomizeNewCombatantStats} // Disable if the main randomize checkbox is checked
                      >
                        Randomize Stats (Manual)
                      </button>
                    </div>
                  </>
                )}

                <button
                  onClick={addCharacter}
                  className="col-span-1 sm:col-span-2 py-3 px-6 bg-pink-600 hover:bg-pink-700 text-white font-bold rounded-xl shadow-md transition-all duration-300 transform hover:scale-105"
                >
                  Add Combatant
                </button>
              </div>
            )}
          </div>

          {/* List of All Added Combatants (Summary) */}
          <div className="p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600">
            <h2 className="text-xl font-bold text-center mb-4 text-gray-200 flex justify-between items-center">
              <span>All Combatants Overview</span>
              <button
                onClick={() => setIsOverviewCollapsed(!isOverviewCollapsed)}
                className="p-1 rounded-full bg-gray-600 hover:bg-gray-500 transition-colors duration-200"
                title={isOverviewCollapsed ? "Expand" : "Collapse"}
              >
                {isOverviewCollapsed ? <ChevronDown className="w-5 h-5" /> : <ChevronUp className="w-5 h-5" />}
              </button>
            </h2>
            <div className={`space-y-2 transition-all duration-300 ease-in-out ${isOverviewCollapsed ? 'max-h-0 overflow-hidden' : 'max-h-[500px] overflow-y-auto'}`}> {/* Dynamic height */}
              {sortedCharactersForSummary.length === 0 ? (
                <p className="text-center text-gray-400 text-sm py-4">No combatants added yet.</p>
              ) : (
                sortedCharactersForSummary.map(char => (
                  <SummaryCharacterCard
                    key={char.id}
                    character={char}
                    onDragStart={handleDragStart}
                    onDragOver={handleDragOver}
                    onDrop={handleDrop}
                    isDraggingOver={dragOverItemId === char.id}
                    onToggleRemovedFromCombat={toggleRemovedFromCombat} // Pass the new function
                    onRemoveAndLoot={handleRemoveAndLoot} // Pass the new function
                    onDeleteCombatant={handleDeleteCombatant} // Pass the new function
                  />
                ))
              )}
            </div>
          </div>

          {/* Loot/XP Pool Toggle and Display */}
          <div className="mt-8">
            <button
              onClick={() => setShowLootPool(!showLootPool)}
              className="w-full py-3 px-6 bg-yellow-600 hover:bg-yellow-700 text-white font-bold rounded-xl shadow-md transition-all duration-300 flex items-center justify-center space-x-2 transform hover:scale-105"
            >
              <Gem className="w-5 h-5" />
              <span>{showLootPool ? 'Hide Loot/XP Pool' : 'Show Loot/XP Pool'}</span>
            </button>

            {showLootPool && (
              <div className="mt-4 p-4 bg-gray-900 rounded-lg shadow-inner border border-gray-700 max-h-60 overflow-y-auto text-sm text-gray-300">
                <div className="font-bold text-lg text-yellow-300 mb-2">Total XP: {totalXpPool}</div> {/* Display total XP */}
                {groupedLootPool.length === 0 ? (
                  <p className="text-center text-gray-500">Loot pool is empty.</p>
                ) : (
                  <ul className="list-disc list-inside space-y-1">
                    {groupedLootPool.map((item, index) => (
                      <li key={`${item.name}-${item.unit || ''}-${item.isCustom || false}-${index}`}>
                        {item.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond for custom items in loot pool */}
                        {item.name}
                        {item.quantity && item.quantity > 1 && ` (${item.quantity})`} {/* Display total quantity */}
                        {item.unit && ` ${item.unit}`}
                        {item.value && ` (Value: ${item.value})`}
                        {item.damage && ` (Damage: ${item.damage})`}
                        {item.ac && ` (AC: ${item.ac})`}
                        {item.effect && ` (Effect: ${item.effect})`}
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            )}
          </div>

          {/* Combat Log Toggle and Display */}
          <div className="mt-8">
            <button
              onClick={() => setShowLog(!showLog)}
              className="w-full py-3 px-6 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl shadow-md transition-all duration-300 flex items-center justify-center space-x-2 transform hover:scale-105"
            >
              <ScrollText className="w-5 h-5" />
              <span>{showLog ? 'Hide Combat Log' : 'Show Combat Log'}</span>
            </button>

            {showLog && (
              <div ref={logRef} className="mt-4 p-4 bg-gray-900 rounded-lg shadow-inner border border-gray-700 h-60 overflow-y-auto text-sm text-gray-300">
                {logEntries.length === 0 ? (
                  <p className="text-center text-gray-500">Log is empty.</p>
                ) : (
                  logEntries.map((entry, index) => {
                    const character = entry.characterId ? characters.find(c => c.id === entry.characterId) : null;
                    const characterName = character ? character.name : '';
                    const characterColor = character ? character.color : 'inherit'; // Fallback to inherit

                    let valueColorClass = 'text-gray-300'; // Default for info types
                    if (entry.type === 'to_hit' || entry.type === 'skill' || entry.type === 'initiative_set') {
                      valueColorClass = 'text-blue-400';
                    } else if (entry.type === 'damage' || (entry.type === 'hp_change' && entry.hpChangeType === 'damage')) {
                      valueColorClass = 'text-red-400';
                    } else if (entry.type === 'hp_change' && entry.hpChangeType === 'heal') {
                      valueColorClass = 'text-green-400';
                    } else if (entry.type === 'death_save') { // New: Death save log entry styling
                      valueColorClass = entry.details.includes('Success') ? 'text-green-400' : 'text-red-400';
                    }

                    return (
                      <div key={index} className="mb-1">
                        <span className="text-gray-500">[{new Date(entry.timestamp).toLocaleTimeString()}]</span>{' '}
                        {characterName ? (
                          <span style={{ color: characterColor }} className="font-semibold">{characterName}</span>
                        ) : null}
                        {' '}
                        {entry.message}{' '}
                        {entry.value !== undefined && (
                          <span className={`${valueColorClass} font-bold`}>{entry.value}</span>
                        )}
                        {entry.details && (
                          <span className="text-gray-400 ml-1">{entry.details}</span>
                        )}
                        {entry.isCrit && (
                          <span className="text-yellow-300 ml-1 font-bold">(CRITICAL!)</span>
                        )}
                      </div>
                    );
                  })
                )}
              </div>
            )}
          </div>

          {/* Undo Deleted Combatants Section */}
          <div className="mt-8">
            <button
              onClick={() => setShowUndoList(!showUndoList)}
              className="w-full py-3 px-6 bg-blue-800 hover:bg-blue-700 text-white font-bold rounded-xl shadow-md transition-all duration-300 flex items-center justify-center space-x-2 transform hover:scale-105"
            >
              <RotateCcw className="w-5 h-5" />
              <span>{showUndoList ? 'Hide Undo List' : `Undo Deleted Combatants (${deletedCharacters.length}/${MAX_UNDO_BUFFER})`}</span>
            </button>

            {showUndoList && (
              <div className="mt-4 p-4 bg-gray-900 rounded-lg shadow-inner border border-gray-700 max-h-60 overflow-y-auto text-sm text-gray-300">
                {deletedCharacters.length === 0 ? (
                  <p className="text-center text-gray-500">No deleted combatants to restore.</p>
                ) : (
                  <ul className="space-y-2">
                    {deletedCharacters.map(char => (
                      <li key={char.id} className="flex justify-between items-center p-2 bg-gray-800 rounded-md border border-gray-700">
                        <span className="font-semibold" style={{ color: char.color }}>
                          {char.isCustom && <span className="text-purple-300 mr-2">◇</span>} {/* Diamond for custom restored characters */}
                          {char.name}
                          {char.wasLooted && <span className="ml-2 text-xs text-yellow-300">(Looted)</span>} {/* Indicator if it was looted */}
                        </span>
                        <button
                          onClick={() => handleRestoreDeletedCharacter(char.id)}
                          className="py-1 px-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors duration-200 text-xs"
                        >
                          Restore
                        </button>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            )}
          </div>

        </div>

        {/* Right Half: Initiative List and Combatant Details */}
        <div className="w-full md:w-1/2 p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600 flex flex-col space-y-3">
          <h2 className="text-3xl font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">
            Initiative Order
          </h2>

          {/* Next Round Button */}
          {characters.length > 0 && (
            <button
              onClick={handleNextRound}
              className="w-full py-3 px-6 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-md transition-all duration-300 flex items-center justify-center space-x-2 transform hover:scale-105 mb-4"
            >
              <Check className="w-5 h-5" />
              <span>Next Round</span>
            </button>
          )}
          {/* Round Counter and Death Saves Toggle */}
          <div className="flex justify-between items-center mb-4">
            {/* Death Saves Toggle Button */}
            <button
              onClick={() => setDeathSavesEnabled(!deathSavesEnabled)}
              className={`py-2 px-4 rounded-lg font-semibold transition-colors duration-200 flex items-center space-x-2
                ${deathSavesEnabled ? 'bg-green-700 text-white hover:bg-green-800' : 'bg-gray-600 text-gray-300 hover:bg-gray-500'}`}
              title={deathSavesEnabled ? "Death Saves are ENABLED" : "Death Saves are DISABLED (0 HP = instant death)"}
            >
              {deathSavesEnabled ? <Check className="w-5 h-5" /> : <Skull className="w-5 h-5" />}
              <span>{deathSavesEnabled ? 'Death Saves: ON' : 'Death Saves: OFF'}</span>
            </button>
            {/* Reroll All Initiatives Button */}
            <button
              onClick={handleRerollAllInitiatives}
              className="py-2 px-4 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 font-semibold transition-colors duration-200 flex items-center space-x-2"
              title="Reroll Initiative for all active combatants"
            >
              <Dice className="w-5 h-5" />
              <span>Reroll All Init</span>
            </button>

            <div className="text-xl font-bold text-gray-200">
              Round: {round}
            </div>
          </div>


          <div className="space-y-3">
            {console.log("Rendering Initiative List. Sorted Characters:", sortedCharactersForInitiative)} {/* Debug log */}
            {sortedCharactersForInitiative.length === 0 ? (
              <p className="text-center text-gray-400 text-xl py-8">No combatants yet! Add some to start tracking.</p>
            ) : (
              sortedCharactersForInitiative.map(char => (
                <MiniCharacterCard
                  key={char.id}
                  character={char}
                  onSelectCharacter={handleSelectCombatant}
                  isSelected={openCombatantIds.has(char.id)} // Check if ID is in the Set
                  onUpdateColor={updateCharacterColor}
                  allColors={COLORS}
                  onUpdateHp={updateCharacterHp}
                  onToggleRemovedFromCombat={toggleRemovedFromCombat} // Pass the new function
                  onUpdateStatus={updateCharacterStatus}
                  onUpdateActionCheckbox={updateActionCheckbox} // Pass new action update function
                  onUpdateCurrentMovement={updateCurrentMovement} // Pass new movement update function
                  onUpdateActions={updateCharacterActions} // Pass the new prop
                  addLogEntry={addLogEntry} // Pass log function
                  onUpdateCharacterName={updateCharacterName} // Pass character name update function
                  // Pass custom weapon states and setters
                  newCustomWeaponName={newCustomWeaponName}
                  setNewCustomWeaponName={setNewCustomWeaponName}
                  newCustomWeaponNumDice={newCustomWeaponNumDice}
                  setNewCustomWeaponNumDice={setNewCustomWeaponNumDice}
                  newCustomWeaponDieType={newCustomWeaponDieType}
                  setNewCustomWeaponDieType={setNewCustomWeaponDieType}
                  newCustomWeaponModifier={newCustomWeaponModifier}
                  setNewCustomWeaponModifier={setNewCustomWeaponModifier}
                  selectedDamageTypeForNewWeapon={selectedDamageTypeForNewWeapon}
                  setSelectedDamageTypeForNewWeapon={setSelectedDamageTypeForNewWeapon}
                  customDamageTypeName={customDamageTypeName}
                  setCustomDamageTypeName={setCustomDamageTypeName}
                  newCustomWeaponToHitModifier={newCustomWeaponToHitModifier}
                  setNewCustomWeaponToHitModifier={setNewCustomWeaponToHitModifier}
                  onTogglePanelLock={onTogglePanelLock} // Pass the setter
                  onUpdateAbilityRoll={updateAbilityRoll} // Pass the new prop
                  onRollDeathSave={handleRollDeathSave} // NEW: Pass the death save handler
                  deathSavesEnabled={deathSavesEnabled} // NEW: Pass the death saves enabled state
                  onActivateTrait={handleActivateTrait} // Pass the new prop
                />
              ))
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default App;

        // At the very end, add this line to render your main component:
        ReactDOM.render(<YourMainComponentName />, document.getElementById('root'));
    </script>
</body>
</html>